#!/bin/bash

# activate if the script should abort on error:
# set -e

SCRIPT_FULL_NAME=$(readlink -e "$0")
#MYDIR=$(dirname "$SCRIPT_FULL_NAME")
MYNAME=$(basename "$SCRIPT_FULL_NAME")

QUEUENAME="default"
TOPPATCHDIR=".gqpatches"
PATCHDIR="$TOPPATCHDIR/$QUEUENAME"
SERIESFILE="$PATCHDIR/series"
PARENTFILE="$PATCHDIR/parent"
QUEUEFILE="$TOPPATCHDIR/queue"

ALL_COMMANDS="bashcompletion change-order commands abort applied backup continue delete fold init log name new parent pop push record refresh unapplied"

ALL_COMMANDS_RX=$(echo "$ALL_COMMANDS" | sed -e 's/ /|/g')

verbose=""
dryrun=""

all=""
rev=""
name=""

cmdret=""
cmddata=""

function CMD {
    # execute a shell command
    # arguments:
    #   $1: command
    # returns:
    #   cmdret (global variable): the return code of the command
    if [ -n "$verbose" ] || [ -n "$dryrun" ]; then
        echo "$1"
    fi
    if [ -z "$dryrun" ]; then
        bash -c "$1"
        cmdret=$?
    else
        cmdret=0
    fi
}

function CMDRET {
    # execute a shell command and catch standard out
    # arguments:
    #   $1: command
    # returns:
    #   cmdret (global variable): the return code of the command
    #   cmddata (global variable): the stdout output of the command
    if [ -n "$verbose" ] || [ -n "$dryrun" ]; then
        echo "$1"
    fi
    cmdret=0
    # without '|| ...' the script will exit right here
    # in case of an error:
    cmddata=$(bash -c "$1") || cmdret=$?
}

function CD {
    # change directory but not when dryrun is set
    # $1: dir
    if [ -n "$verbose" ] || [ -n "$dryrun" ]; then
        echo "cd $1"
    fi
    if [ -z "$dryrun" ]; then
        if ! cd "$1" > /dev/null; then
            echo "cd $1 failed!"
            exit 1
        fi
    fi
}

function git_head_log {
    # $1: name of file to create
    CMD "git log -1 --pretty=%B > $1"
}

function git_add_changes {
    # add only changes files to stash
    CMD "git status --porcelain | grep -v '^??' | sed -e 's/^.. //' | xargs git add"
}

function git_select_changes {
    # add only changes files to stash
    CMD "git add --patch"
}

function git_add_all_changes {
    # add all changes except patchqueue files
    CMD "git status --porcelain | sed -e 's/^.. //' | grep -v '\(^$PATCHDIR[/-]\|\.rej$\)'| xargs git add"
}

function git_amend {
    # simple amend of HEAD revision
    # $1: if not empty, take log message from here
    EXTRA=""
    if [ -n "$1" ]; then
        EXTRA="-F $1"
    fi
    git_add_changes
    CMD "git commit --amend $EXTRA"
}

function select_queue {
    # $1: queue name
    # modifies global variables: QUEUENAME, PATCHDIR, SERIESFILE,
    #                            PARENTFILE
    QUEUENAME="$1"
    PATCHDIR="$TOPPATCHDIR/$QUEUENAME"
    SERIESFILE="$PATCHDIR/series"
    PARENTFILE="$PATCHDIR/parent"
}

function qpop_check {
    # returns 0 if qpop is not beyond parent,
    # returns 1 when qpop is not allowed.
    # $1: if non-zero, instead of returning 1 abort with an error message
    CMDRET "git rev-parse --short HEAD"
    rev="$cmddata"
    CMD "[ ! -s $PARENTFILE ] || [ $(cat $PARENTFILE) != $cmddata ]"
    if [ "$cmdret" -ne 0 ]; then
        if [ -n "$1" ]; then
            echo "cannot do qpop, parent revision $rev reached" >&2
            exit 1
        else
            return 1
        fi
    fi
    return 0
}

function qpop_one {
    # do a single 'qpop' operation.
    CMD "git format-patch -o $PATCHDIR -1 HEAD > $PATCHDIR/NEW-1"
    CMD "sed -e 's#$PATCHDIR/0001-##' $PATCHDIR/NEW-1 > $PATCHDIR/NEW"
    CMD "mv $(cat $PATCHDIR/NEW-1) $PATCHDIR/$(cat $PATCHDIR/NEW)"
    CMD "if [ ! -s $SERIESFILE ]; then cat $PATCHDIR/NEW > $SERIESFILE; else sed -i \"1i$(cat $PATCHDIR/NEW)\" $SERIESFILE; fi"
    CMD "rm -f $PATCHDIR/NEW-1 $PATCHDIR/NEW"
    CMD "git reset --hard HEAD~1"
}

function qpush_specified {
    # $1: name of patch
    if [ ! -s "$SERIESFILE" ]; then
        echo "error, no patches in $SERIESFILE"
        exit 1
    fi
    CMD "grep -F -e '$name' $SERIESFILE > $PATCHDIR/NEW"
    if [ ! -s "$PATCHDIR/NEW" ]; then
        echo "error, patch '$name' not found in $SERIESFILE, maybe the patch is alraedy applied" >&2
        exit 1
    fi
    CMD "grep -v -F -e '$name' $SERIESFILE > $SERIESFILE.new"
    CMD "git am --reject $PATCHDIR/$(cat $PATCHDIR/NEW)"
    if [ "$cmdret" -ne 0 ]; then
        echo "The patch to be folded could not be applied."
        echo "Fix the change by looking at the *.rej files."
        echo "Then run:"
        echo "  $MYNAME continue"
        echo "To abort the operation without fixing run:"
        echo "  $MYNAME abort"
        exit 1
    fi
    CMD "cp -a $SERIESFILE.new $SERIESFILE && rm -f $SERIESFILE.new $PATCHDIR/NEW"
}

function qpush_one {
    # do a single 'qpush' operation.
    if [ ! -s "$SERIESFILE" ]; then
        echo "error, no patches in $SERIESFILE"
        exit 1
    fi
    CMD "head -n 1 $SERIESFILE > $PATCHDIR/NEW"
    CMD "cp -a $SERIESFILE $SERIESFILE.new && sed -i -e '1d' $SERIESFILE.new"
    CMD "git am --reject $PATCHDIR/$(cat $PATCHDIR/NEW)"
    if [ "$cmdret" -ne 0 ]; then
        echo "Fix the change by looking at the *.rej files."
        echo "Then run:"
        echo "  $MYNAME continue"
        echo "To abort the operation without fixing run:"
        echo "  $MYNAME abort"
        exit 1
    fi
    CMD "cp -a $SERIESFILE.new $SERIESFILE && rm -f $SERIESFILE.new $PATCHDIR/NEW"
}

function qdelete {
    # $1: name of patch to delete
    if [ ! -e "$PATCHDIR/$name" ]; then
        echo "error, patch '$name' doesn't exist."
        exit 1
    fi
    CMD "rm $PATCHDIR/$name"
    CMD "if [ -s $SERIESFILE ]; then cp -a $SERIESFILE $SERIESFILE.bak && grep -v -F -e '$name' $SERIESFILE.bak > $SERIESFILE && rm -f $SERIESFILE.bak; fi"
}

function create_parentfile {
    # $1: revision
    CMDRET "git rev-parse --short $1"
    if [ "$cmdret" -ne 0 ]; then
        echo "invalid revision: $1" >&2
        exit 1
    fi
    if [ "$1" == "$cmddata" ]; then
        echo "queue parent revision set to $1"
    else
        echo "queue parent revision set to $1 ($cmddata)"
    fi
    CMD "echo $cmddata > $PARENTFILE"
}

function print_short_help {
    GIT_SUBCMD="$(echo "$MYNAME" | sed -e 's/git-//')"
    echo "$MYNAME : handle git patch queues"
    echo
    echo "usage: git $GIT_SUBCMD COMMAND [OPTIONS]"
    echo
    echo "Known COMMANDS":
    echo
    echo "Completion:"
    echo
    echo "  commands       : list all known commands on the console"
    echo "  bashcompletion : list the line you have to add to your .bashrc"
    echo "                   to integrate completion into the 'git' command."
    echo
    echo "Quene management:"
    echo "  init [QNAME]   : create/select a patch queue with name 'QNAME'."
    echo "                   QNAME is optional, the default patch queue name is"
    echo "                   'default'."
    echo "                   You must run this command once to initialize the"
    echo "                   patch queue in your repository."
    echo "  name [QNAME]   : if QNAME is not given, show current patch queue name."
    echo "                   if QNAME is given, change to patch queue QNAME."
    echo "  backup         : create backup tar file of patch directory"
    echo "                   '$TOPPATCHDIR'."
    echo "  change-order   : call an editor to edit the file that contains all"
    echo "                   currently unapplied patches. Note the the patches"
    echo "                   in the file are applied from top to bottom."
    echo "  applied        : show all applied patches up to parent+1"
    echo "  unapplied      : show all patches of the patch queue"
    echo "  parent [REV}   : Set REV as patch queue parent revision. Do never go "
    echo "                   beyond this revision with pop. Use 'HEAD' to set your"
    echo "                   repository HEAD as parent revision."
    echo "                   If HEAD is not given, show the current parent revision."
    echo
    echo "Patch management:"
    echo "  new [NAME]     : create new patch (commit with log-message NAME)"
    echo "  record [NAME]  : interactively select changes for a new patch"
    echo "                   (commit with log-message NAME)"
    echo "  refresh        : update the topmost patch"
    echo "  pop            : pop the topmost patch."
    echo "  push           : apply the top patch from the patch queue"
    echo "  fold NAME      : fold patch 'NAME' to the topmost patch. Patch 'name'"
    echo "                   must not be appled already."
    echo "  delete NAME    : delete unapplied patch with given name."
    echo "  continue       : continue 'push' after you had a conflict and had"
    echo "                   it fixed manually."
    echo "  abort          : abort (undo) 'push' after you had a conflict and could"
    echo "                   not fix it manually."
    echo
    echo "Miscellaneous"
    echo "  log            : Display git patches as a tree in the terminal."
    echo
    echo "OPTIONS:"
    echo "-h --help    : show help"
    echo "-H --HELP    : show help without pager"
    echo "-a --all     : push: push ALL patches"
    echo "               pop : pop ALL patches"
    echo "-v --verbose : show what the script does"
    echo "-n --dry-run : just show what the script would do"
}

declare -a ARGS
skip_options=""

while true; do
    case "$1" in
        -h | --help)
            # if the "less" is present, use it:
            if less -V >/dev/null 2>&1; then
                # use less pager for help:
                $SCRIPT_FULL_NAME --HELP | less
                exit 0
            else
                print_short_help
                exit 0
            fi
            ;;
        -H | --HELP)
            print_short_help
            exit 0
            ;;
        -a | --all)
            all="yes"
            shift
            ;;
        -v | --verbose)
            verbose="yes"
            shift
            ;;
        -n | --dry-run)
            verbose="yes"
            dryrun="yes"
            shift
            ;;
        -- )
            skip_options="yes"
            shift;
            break
            ;;
        *)
            if [ -z "$1" ]; then
                break;
            fi
            if [[ $1 =~ ^- ]]; then
                echo "unknown option: $1"
                exit 1
            fi
            ARGS+=("$1")
            shift
            ;;
    esac
done

if [ -n "$skip_options" ]; then
    while true; do
        if [ -z "$1" ]; then
            break;
        fi
        ARGS+=("$1")
        shift
    done
fi

COMMAND=""

for arg in "${ARGS[@]}"; do
    # examine extra args
    # match known args here like:
    # if [ "§arg" == "doit" ]; then ...
    #     continue
    # fi
    if [ "$COMMAND" == "parent" ]; then
        if [ -n "$rev" ]; then
            echo "unexpected: '$arg'" >&2
            exit 1
        fi
        rev="$arg"
        continue
    fi
    if [[ "$COMMAND" =~ init|fold|new|record|delete ]]; then
        if [ -n "$name" ]; then
            echo "unexpected: '$arg'" >&2
            exit 1
        fi
        name="$arg"
        continue
    fi
    if [[ "$arg" =~ $ALL_COMMANDS_RX ]]; then
        if [ -n "$COMMAND" ]; then
            echo "unexpected: '$arg'" >&2
            exit 1
        fi
        COMMAND="$arg"
        continue
    fi
    echo "unexpeced argument: $arg"
    exit 1
done

if [ -z "$COMMAND" ]; then
    if less -V >/dev/null 2>&1; then
        # use less pager for help:
        $SCRIPT_FULL_NAME --HELP | less
        exit 0
    else
        print_short_help
        exit 0
    fi
fi

if [ "$COMMAND" == "commands" ]; then
    echo -n "$ALL_COMMANDS"
    exit 0
fi

if [ "$COMMAND" == "bashcompletion" ]; then
    echo '_git_gq() { __gitcomp "$(git-gq commands)" "" "$cur"; }'
    exit 0
fi

if [ ! -d .git ]; then
    echo "error, '.git' not found" >&2
    exit 1
fi

if [ "$COMMAND" == "init" ]; then
    if [ -n "$name" ]; then
        QUEUENAME="$name"
    fi
    mkdir -p "$TOPPATCHDIR"
    echo "$QUEUENAME" > "$QUEUEFILE"
    select_queue "$QUEUENAME"
    mkdir -p "$TOPPATCHDIR/$QUEUENAME"
    if [ ! -s "$PARENTFILE" ]; then
        create_parentfile HEAD
    fi
    exit 0
fi

if [ ! -d "$TOPPATCHDIR" ]; then
    echo "please run '$MYNAME init' first." >&2
    exit 1
fi

if [ "$COMMAND" == "name" ]; then
    if [ -z "$name" ]; then
        QUEUENAME=$(cat "$QUEUEFILE")
        echo "Existing queues:"
        CMD "cd $TOPPATCHDIR && ls -d */ | sed -e 's#/##;s/^/\\t/'"
        echo
        echo "Currently selected:"
        echo -e "\t$QUEUENAME"
        exit 0
    else
        echo "$QUEUENAME" > "$QUEUEFILE"
        select_queue "$QUEUENAME"
        mkdir -p "$PATCHDIR/$QUEUENAME"
        if [ ! -s "$PARENTFILE" ]; then
            create_parentfile HEAD
        fi
    fi
fi

QUEUENAME=$(cat "$QUEUEFILE")
if [ ! -d "$PATCHDIR" ]; then
    echo "error: $PATCHDIR does not exist" >&2
    exit 1
fi
select_queue "$QUEUENAME"

if [ "$COMMAND" == "backup" ]; then
    date_=$(date '+%Y-%m-%dT%H%M%S')
    CMD "tar -czf $TOPPATCHDIR-$date_.tgz $TOPPATCHDIR"
    exit 0
fi

if [ "$COMMAND" == "change-order" ]; then
    editor="$EDITOR"
    if [ -z "$EDITOR" ]; then
        editor="$VISUAL"
    fi
    if [ -z "$EDITOR" ]; then
        echo "Caution: default editor not set, using 'vi' instead."
        echo "Note that you can abort editing with"
        echo "  <ESC> :qa!"
        read -p "Enter 'y' or 'Y' to continue, everything else aborts " -n 1 -r
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 1
        fi
        editor="vi"
    fi
    $editor "$SERIESFILE"
    exit 0
fi

if [ "$COMMAND" == "log" ]; then
    CMD "git log --graph --all --decorate"
    exit 0
fi

if [ "$COMMAND" == "parent" ]; then
    if [ -z "$rev" ]; then 
        if [ ! -s "$PARENTFILE" ]; then
            echo "no PARENT revision defined"
        else
            echo "Parent: $(cat $PARENTFILE)"
        fi
        exit 0
    fi
    create_parentfile "$rev"
    exit 0
fi

if [ "$COMMAND" == "new" ]; then
    git_add_changes
    if [ -n "$name" ]; then
        name="-m '$name'"
    fi
    CMD "git commit $name"
    exit 0
fi

if [ "$COMMAND" == "record" ]; then
    git_select_changes
    if [ -n "$name" ]; then
        name="-m '$name'"
    fi
    CMD "git commit $name"
    exit 0
fi

if [ "$COMMAND" == "refresh" ]; then
    git_amend ""
    exit 0
fi

if [ "$COMMAND" == "delete" ]; then
    if [ -z "$name" ]; then
        echo "error, patchname is missing" >&2
        exit 1
    fi
    qdelete "$name"
    exit 0
fi

if [ "$COMMAND" == "pop" ]; then
    abort_on_err=""
    if [ -z "$all" ]; then
        abort_on_err="yes"
    else
        if [ ! -s "$PARENTFILE" ]; then
            echo "Error, 'pop -a' not allowed when no parent revision is defined." >&2
            exit 1
        fi
    fi
    while true; do
        if ! qpop_check "$abort_on_err"; then
            break
        fi
        qpop_one
        if [ -z "$all" ]; then
            break
        fi
    done
    exit 0
fi

if [ "$COMMAND" == "push" ]; then
    while true; do
        if [ ! -s $SERIESFILE ]; then
            break
        fi
        qpush_one
        if [ -z "$all" ]; then
            break
        fi
    done
    exit 0
fi

if [ "$COMMAND" == "fold" ]; then
    if [ -z "$name" ]; then
        echo "error, patchname is missing" >&2
        exit 1
    fi
    git_head_log "$PATCHDIR/LOG"
    CMD "echo -e '\n***\n' >> $PATCHDIR/LOG"
    qpush_specified "$name"
    git_head_log "$PATCHDIR/LOG2"
    CMD "cat $PATCHDIR/LOG2 >> $PATCHDIR/LOG && rm -f $PATCHDIR/LOG2"
    qpop_one
    CMD "git apply $PATCHDIR/$name"
    git_amend "$PATCHDIR/LOG"
    CMD "rm -f $PATCHDIR/LOG"
    qdelete "$name"
    echo "Note: Log messages were combined into one" >&2
    exit 0
fi

if [ "$COMMAND" == "applied" ]; then
    if [ -s $PARENTFILE ]; then
        CMDRET "cat $PARENTFILE"
        START="${cmddata}.."
    fi
    CMD "git log --color=always --oneline $START | cat"
    exit 0
fi

if [ "$COMMAND" == "unapplied" ]; then
    if [ -s $SERIESFILE ]; then
        CMD "cat $SERIESFILE"
    fi
    exit 0
fi

if [ "$COMMAND" == "continue" ]; then
    CMD "git status --porcelain | sed -e 's/^.. //' | grep -v '\(^$PATCHDIR/\|\.rej$\)'| xargs git add"
    CMD "git am --continue"
    if [ "$cmdret" -ne 0 ]; then
        echo "Fix the change by looking at the *.rej files."
        echo "Then run:"
        echo "  $MYNAME qcontinue"
        echo "To abort the operation without fixing run:"
        echo "  $MYNAME qabort"
    fi
    CMD "if [ -e $SERIESFILE.new ]; then cp -a $SERIESFILE.new $SERIESFILE && rm -f $SERIESFILE.new; fi"
    exit 0
fi

if [ "$COMMAND" == "abort" ]; then
    CMD "git am --abort"
    CMD "rm -f $SERIESFILE.new"
    exit 0
fi

if [ "$COMMAND" == "continue" ]; then
    git_add_all_changes
    CMD "git am --continue"
    if [ "$cmdret" -ne 0 ]; then
        echo "Fix the change by looking at the *.rej files."
        echo "Then run:"
        echo "  $MYNAME qcontinue"
    fi
    exit 0
fi
