#!/bin/bash

# activate if the script should abort on error:
# set -e

SCRIPT_FULL_NAME=$(readlink -e "$0")
#MYDIR=$(dirname "$SCRIPT_FULL_NAME")
MYNAME=$(basename "$SCRIPT_FULL_NAME")

MYNAME_GIT="$(echo "$MYNAME" | sed -s 's/-/ /')"

QUEUENAME="default"
TOPPATCHDIR=".gqpatches"
PATCHDIR="$TOPPATCHDIR/$QUEUENAME"
SERIESFILE="$PATCHDIR/series"
PARENTFILE="$PATCHDIR/parent"
QUEUEFILE="$TOPPATCHDIR/queue"

ALL_COMMANDS="bashcompletion change-order commands abort applied backup continue delete dump fold init log name new parent pop push record refresh unapplied"

# shellcheck disable=SC2001
ALL_COMMANDS_RX=$(echo "$ALL_COMMANDS" | sed -e 's/ /|/g')

all=""
rev=""
name=""

function git_goto_repo_dir {
    while [ "$(pwd)" != "/" ]; do
        if [ -d ".git" ]; then
            break;
        fi
        cd .. || exit 1
    done
    if [ ! -d ".git" ]; then
        echo "error, '.git' not found" >&2
        exit 1
    fi
}


function git_head_log {
    # $1: name of file to create
    git log -1 --pretty=%B > "$1"
}

function git_add_changes {
    # add only changes files to stash
    git status --porcelain | grep -v '^??' | sed -e 's/^.. //' | xargs git add
}

function git_select_changes {
    # add only changes files to stash
    git add --patch
}

function git_add_all_changes {
    # add all changes except patchqueue files
    git status --porcelain | sed -e 's/^.. //' | grep -v "\(^${PATCHDIR}[/-]\|\.rej$\)" | xargs git add
}

function git_amend {
    # simple amend of HEAD revision
    # $1: if not empty, take log message from here
    EXTRA=""
    if [ -n "$1" ]; then
        EXTRA="-F $1"
    fi
    git_add_changes
    git commit --amend "$EXTRA"
}

function select_queue {
    # $1: queue name
    # modifies global variables: QUEUENAME, PATCHDIR, SERIESFILE,
    #                            PARENTFILE
    QUEUENAME="$1"
    PATCHDIR="$TOPPATCHDIR/$QUEUENAME"
    SERIESFILE="$PATCHDIR/series"
    PARENTFILE="$PATCHDIR/parent"
}

function qpop_check {
    # returns 0 if qpop is not beyond parent,
    # returns 1 when qpop is not allowed.
    # $1: if non-zero, instead of returning 1 abort with an error message
    rev=$(git rev-parse --short HEAD)
    if [ -s "$PARENTFILE" ] && [ "$(cat "$PARENTFILE")" == "$rev" ]; then
        if [ -n "$1" ]; then
            echo "Cannot perform pop, parent revision $rev reached." >&2
            echo "You could change the parent with '$MYNAME_GIT parent REV'." >&2
            exit 1
        else
            return 1
        fi
    fi
    return 0
}

function qpop_one {
    # do a single 'qpop' operation.
    local ORIG_PATCHNAME
    local PATCHNAME
    local TEMP_PATCHNAME
    local CNT
    ORIG_PATCHNAME=$(git format-patch -o "$TOPPATCHDIR" -1 HEAD | sed -e "s#^$TOPPATCHDIR/##")
    # remove leading number from patchname:
    # shellcheck disable=SC2001
    PATCHNAME=$(echo "$ORIG_PATCHNAME"  | sed -e 's/^[0-9]\+-//')
    # if a file with this name already exists:
    if [ -e "$PATCHDIR/$PATCHNAME" ]; then
        # generate a filename with a preceeding number
        CNT=1
        while true; do
            TEMP_PATCHNAME="$(printf "%04d-%s" "$CNT" "$PATCHNAME")"
            if [ ! -e "$PATCHDIR/$TEMP_PATCHNAME" ]; then
                break
            fi
            CNT=$((CNT+1))
        done
        PATCHNAME="$TEMP_PATCHNAME"
    fi
    mv "$TOPPATCHDIR/$ORIG_PATCHNAME" "$PATCHDIR/$PATCHNAME"
    if [ ! -s "$SERIESFILE" ]; then
        echo "$PATCHNAME" > "$SERIESFILE"
    else
        # insert at first line
        sed -i "1i$PATCHNAME" "$SERIESFILE"
    fi
    git reset --hard HEAD~1
}

function qpush_specified {
    # $1: name of patch
    local PATCHNAME
    if [ ! -s "$SERIESFILE" ]; then
        echo "error, no patches in $SERIESFILE"
        exit 1
    fi
    PATCHNAME=$(grep -F -e "$name" "$SERIESFILE")
    if [ -z "$PATCHNAME" ]; then 
        echo "error, patch '$name' not found in $SERIESFILE, maybe the patch is alraedy applied" >&2
        exit 1
    fi
    echo "$PATCHNAME" > "$PATCHDIR/PUSH"
    # remove PATCHNAME from SERIESFILE:
    grep -v -F -e "$name" "$SERIESFILE" > "$SERIESFILE.new"
    if ! git am --reject "$PATCHDIR/$PATCHNAME"; then
        echo "The patch to be folded could not be applied."
        echo "Fix the change by looking at the *.rej files."
        echo "Then run:"
        echo "  $MYNAME continue"
        echo "To abort the operation without fixing run:"
        echo "  $MYNAME abort"
        exit 1
    fi
    rm -f "$PATCHDIR/$PATCHNAME" "$PATCHDIR/PUSH" "$SERIESFILE" && mv "$SERIESFILE.new" "$SERIESFILE"
}

function qpush_one {
    # do a single 'qpush' operation.
    local PATCHNAME
    if [ ! -s "$SERIESFILE" ]; then
        echo "error, no patches in $SERIESFILE"
        exit 1
    fi
    PATCHNAME=$(head -n 1 "$SERIESFILE")
    echo "$PATCHNAME" > "$PATCHDIR/PUSH"
    # remove PATCHNAME from SERIESFILE:
    cp -a "$SERIESFILE" "$SERIESFILE.new" && sed -i -e '1d' "$SERIESFILE.new"
    if ! git am --reject "$PATCHDIR/$PATCHNAME"; then
        echo "Fix the change by looking at the *.rej files."
        echo "Then run:"
        echo "  $MYNAME continue"
        echo "To abort the operation without fixing run:"
        echo "  $MYNAME abort"
        exit 1
    fi
    rm -f "$PATCHDIR/$PATCHNAME" "$PATCHDIR/PUSH" "$SERIESFILE" && mv "$SERIESFILE.new" "$SERIESFILE"
}

function qdelete {
    # $1: name of patch to delete
    if [ ! -e "$PATCHDIR/$name" ]; then
        echo "error, patch '$name' doesn't exist."
        exit 1
    fi
    rm "$PATCHDIR/$name"
    if [ -s "$SERIESFILE" ]; then
        cp -a "$SERIESFILE" "$SERIESFILE.bak" && grep -v -F -e "$name" "$SERIESFILE.bak" > "$SERIESFILE" && rm -f "$SERIESFILE.bak;"
    fi
}

function create_parentfile {
    # $1: revision
    rev=$(git rev-parse --short "$1")
    # shellcheck disable=SC2181
    if [ $? -ne 0 ]; then
        echo "invalid revision: $1" >&2
        exit 1
    fi
    if [ "$1" == "$rev" ]; then
        echo "queue parent revision set to $1"
    else
        echo "queue parent revision set to $1 ($rev)"
    fi
    echo "$rev" > "$PARENTFILE"
}

function print_short_help {
    # shellcheck disable=SC2001
    echo "$MYNAME : handle git patch queues"
    echo
    echo "usage: $MYNAME_GIT COMMAND [OPTIONS]"
    echo
    echo "Known COMMANDS":
    echo
    echo "Completion:"
    echo
    echo "  commands       : list all known commands on the console"
    echo "  bashcompletion : list the line you have to add to your .bashrc"
    echo "                   to integrate completion into the 'git' command."
    echo
    echo "Quene management:"
    echo "  init [QNAME]   : create/select a patch queue with name 'QNAME'."
    echo "                   QNAME is optional, the default patch queue name is"
    echo "                   'default'."
    echo "                   You must run this command once to initialize the"
    echo "                   patch queue in your repository."
    echo "  name [QNAME]   : if QNAME is not given, show current patch queue name."
    echo "                   if QNAME is given, change to patch queue QNAME."
    echo "  backup         : create backup tar file of patch directory"
    echo "                   '$TOPPATCHDIR'."
    echo "  change-order   : call an editor to edit the file that contains all"
    echo "                   currently unapplied patches. Note the the patches"
    echo "                   in the file are applied from top to bottom."
    echo "  applied        : show all applied patches up to parent+1"
    echo "  unapplied      : show all patches of the patch queue"
    echo "  parent [REV}   : Set REV as patch queue parent revision. Do never go "
    echo "                   beyond this revision with pop. Use 'HEAD' to set your"
    echo "                   repository HEAD as parent revision."
    echo "                   If HEAD is not given, show the current parent revision."
    echo
    echo "Patch management:"
    echo "  new [NAME]     : create new patch (commit with log-message NAME)"
    echo "  record [NAME]  : interactively select changes for a new patch"
    echo "                   (commit with log-message NAME)"
    echo "  refresh        : update the topmost patch"
    echo "  pop            : pop the topmost patch."
    echo "  push           : apply the top patch from the patch queue"
    echo "  fold NAME      : fold patch 'NAME' to the topmost patch. Patch 'name'"
    echo "                   must not be appled already."
    echo "  delete NAME    : delete unapplied patch with given name."
    echo "  dump NAME      : dump an unapplied patch to the console."
    echo "  continue       : continue 'push' after you had a conflict and had"
    echo "                   it fixed manually."
    echo "  abort          : abort (undo) 'push' after you had a conflict and could"
    echo "                   not fix it manually."
    echo
    echo "Miscellaneous"
    echo "  log            : Display git patches as a tree in the terminal."
    echo
    echo "OPTIONS:"
    echo "-h --help    : show help"
    echo "-H --HELP    : show help without pager"
    echo "-a --all     : push: push ALL patches"
    echo "               pop : pop ALL patches"
}

declare -a ARGS
skip_options=""

while true; do
    case "$1" in
        -h | --help)
            # if the "less" is present, use it:
            if less -V >/dev/null 2>&1; then
                # use less pager for help:
                $SCRIPT_FULL_NAME --HELP | less
                exit 0
            else
                print_short_help
                exit 0
            fi
            ;;
        -H | --HELP)
            print_short_help
            exit 0
            ;;
        -a | --all)
            all="yes"
            shift
            ;;
        -- )
            skip_options="yes"
            shift;
            break
            ;;
        *)
            if [ -z "$1" ]; then
                break;
            fi
            if [[ $1 =~ ^- ]]; then
                echo "unknown option: $1"
                exit 1
            fi
            ARGS+=("$1")
            shift
            ;;
    esac
done

if [ -n "$skip_options" ]; then
    while true; do
        if [ -z "$1" ]; then
            break;
        fi
        ARGS+=("$1")
        shift
    done
fi

COMMAND=""

for arg in "${ARGS[@]}"; do
    # examine extra args
    # match known args here like:
    # if [ "§arg" == "doit" ]; then ...
    #     continue
    # fi
    if [ "$COMMAND" == "parent" ]; then
        if [ -n "$rev" ]; then
            echo "unexpected: '$arg'" >&2
            exit 1
        fi
        rev="$arg"
        continue
    fi
    if [[ "$COMMAND" =~ init|fold|new|record|delete|dump ]]; then
        if [ -n "$name" ]; then
            echo "unexpected: '$arg'" >&2
            exit 1
        fi
        name="$arg"
        continue
    fi
    if [[ "$arg" =~ $ALL_COMMANDS_RX ]]; then
        if [ -n "$COMMAND" ]; then
            echo "unexpected: '$arg'" >&2
            exit 1
        fi
        COMMAND="$arg"
        continue
    fi
    echo "unexpeced argument: $arg"
    exit 1
done

if [ -z "$COMMAND" ]; then
    if less -V >/dev/null 2>&1; then
        # use less pager for help:
        $SCRIPT_FULL_NAME --HELP | less
        exit 0
    else
        print_short_help
        exit 0
    fi
fi

if [ "$COMMAND" == "commands" ]; then
    echo -n "$ALL_COMMANDS"
    exit 0
fi

if [ "$COMMAND" == "bashcompletion" ]; then
    # shellcheck disable=SC2016
    echo '_git_gq() { __gitcomp "$(git-gq commands)" "" "$cur"; }'
    exit 0
fi

git_goto_repo_dir

if [ "$COMMAND" == "init" ]; then
    if [ -n "$name" ]; then
        QUEUENAME="$name"
    fi
    mkdir -p "$TOPPATCHDIR"
    echo "$QUEUENAME" > "$QUEUEFILE"
    select_queue "$QUEUENAME"
    mkdir -p "$TOPPATCHDIR/$QUEUENAME"
    if [ ! -s "$PARENTFILE" ]; then
        create_parentfile HEAD
    fi
    exit 0
fi

if [ ! -d "$TOPPATCHDIR" ]; then
    echo "please run '$MYNAME init' first." >&2
    exit 1
fi

if [ "$COMMAND" == "name" ]; then
    if [ -z "$name" ]; then
        QUEUENAME=$(cat "$QUEUEFILE")
        echo "Existing queues:"
        (cd $TOPPATCHDIR && find . -type d | grep -v '^\.$' | sed -e 's#^\./##')
        echo
        echo "Currently selected:"
        echo -e "\t$QUEUENAME"
        exit 0
    else
        echo "$QUEUENAME" > "$QUEUEFILE"
        select_queue "$QUEUENAME"
        mkdir -p "$PATCHDIR/$QUEUENAME"
        if [ ! -s "$PARENTFILE" ]; then
            create_parentfile HEAD
        fi
    fi
fi

QUEUENAME=$(cat "$QUEUEFILE")
if [ ! -d "$PATCHDIR" ]; then
    echo "error: $PATCHDIR does not exist" >&2
    exit 1
fi
select_queue "$QUEUENAME"

if [ "$COMMAND" == "backup" ]; then
    date_=$(date '+%Y-%m-%dT%H%M%S')
    tar -czf "$TOPPATCHDIR-$date_.tgz" "$TOPPATCHDIR"
    exit 0
fi

if [ "$COMMAND" == "change-order" ]; then
    editor="$EDITOR"
    if [ -z "$EDITOR" ]; then
        editor="$VISUAL"
    fi
    if [ -z "$EDITOR" ]; then
        echo "Caution: default editor not set, using 'vi' instead."
        echo "Note that you can abort editing with"
        echo "  <ESC> :qa!"
        read -p "Enter 'y' or 'Y' to continue, everything else aborts " -n 1 -r
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 1
        fi
        editor="vi"
    fi
    $editor "$SERIESFILE"
    exit 0
fi

if [ "$COMMAND" == "log" ]; then
    git log --graph --all --decorate
    exit 0
fi

if [ "$COMMAND" == "parent" ]; then
    if [ -z "$rev" ]; then 
        if [ ! -s "$PARENTFILE" ]; then
            echo "no PARENT revision defined"
        else
            echo "Parent: $(cat "$PARENTFILE")"
        fi
        exit 0
    fi
    create_parentfile "$rev"
    exit 0
fi

if [ "$COMMAND" == "new" ]; then
    git_add_changes
    if [ -n "$name" ]; then
        name="-m '$name'"
    fi
    git commit "$name"
    exit 0
fi

if [ "$COMMAND" == "record" ]; then
    git_select_changes
    if [ -n "$name" ]; then
        name="-m '$name'"
    fi
    git commit "$name"
    exit 0
fi

if [ "$COMMAND" == "refresh" ]; then
    git_amend ""
    exit 0
fi

if [ "$COMMAND" == "delete" ]; then
    if [ -z "$name" ]; then
        echo "error, patchname is missing" >&2
        exit 1
    fi
    qdelete "$name"
    exit 0
fi

if [ "$COMMAND" == "pop" ]; then
    abort_on_err=""
    if [ -z "$all" ]; then
        abort_on_err="yes"
    else
        if [ ! -s "$PARENTFILE" ]; then
            echo "Error, 'pop -a' not allowed when no parent revision is defined." >&2
            exit 1
        fi
    fi
    while true; do
        if ! qpop_check "$abort_on_err"; then
            break
        fi
        qpop_one
        if [ -z "$all" ]; then
            break
        fi
    done
    exit 0
fi

if [ "$COMMAND" == "push" ]; then
    while true; do
        qpush_one
        if [ -z "$all" ]; then
            break
        else
            # with "--all", reaching the end is no error:
            if [ ! -s "$SERIESFILE" ]; then
                break
            fi
        fi
    done
    exit 0
fi

if [ "$COMMAND" == "fold" ]; then
    if [ -z "$name" ]; then
        echo "error, patchname is missing" >&2
        exit 1
    fi
    git_head_log "$PATCHDIR/LOG"
    echo -e '\n***\n' >> "$PATCHDIR/LOG"
    qpush_specified "$name"
    git_head_log "$PATCHDIR/LOG2"
    cat "$PATCHDIR/LOG2" >> "$PATCHDIR/LOG" && rm -f "$PATCHDIR/LOG2"
    qpop_one
    git apply "$PATCHDIR/$name"
    git_amend "$PATCHDIR/LOG"
    rm -f "$PATCHDIR/LOG"
    qdelete "$name"
    echo "Note: Log messages were combined into one" >&2
    exit 0
fi

if [ "$COMMAND" == "dump" ]; then
    if [ ! -e "$PATCHDIR/$name" ]; then
        echo "error, patch '$name' not found" >&2
        exit 1
    fi
    colordiff < "$PATCHDIR/$name" | less -R
    exit 0
fi

if [ "$COMMAND" == "applied" ]; then
    if [ -s "$PARENTFILE" ]; then
        START="$(cat "$PARENTFILE").."
    fi
    git log --color=always --oneline "$START" | cat
    exit 0
fi

if [ "$COMMAND" == "unapplied" ]; then
    if [ -s "$SERIESFILE" ]; then
        cat "$SERIESFILE"
    fi
    exit 0
fi

if [ "$COMMAND" == "continue" ]; then
    git status --porcelain | sed -e "s/^.. //" | grep -v "\(^$PATCHDIR/\|\.rej$\)"| xargs git add
    if ! git am --continue; then
        echo "Fix the change by looking at the *.rej files."
        echo "Then run:"
        echo "  $MYNAME qcontinue"
        echo "To abort the operation without fixing run:"
        echo "  $MYNAME qabort"
        exit 1
    fi
    if [ -e "$SERIESFILE.new" ]; then
        cp -a "$SERIESFILE.new" "$SERIESFILE" 
    fi
    name=$(cat "$PATCHDIR/PUSH")
    rm -f "$SERIESFILE.new;" "$PATCHDIR/$name" "$PATCHDIR/PUSH"
    exit 0
fi

if [ "$COMMAND" == "abort" ]; then
    git am --abort
    rm -f "$SERIESFILE.new" "$PATCHDIR/PUSH"
    exit 0
fi

if [ "$COMMAND" == "continue" ]; then
    git_add_all_changes
    if ! git am --continue; then
        echo "Fix the change by looking at the *.rej files."
        echo "Then run:"
        echo "  $MYNAME qcontinue"
    fi
    if [ -e "$SERIESFILE.new" ]; then
        rm "$SERIESFILE" && mv "$SERIESFILE.new" "$SERIESFILE"
    fi
    exit 0
fi
