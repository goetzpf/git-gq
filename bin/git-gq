#!/bin/bash

#    git-gq : a patch queue for git
#    Copyright (C) 2025  Goetz Pfeiffer <goetzpf@googlemail.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.


# activate if the script should abort on error:
# set -e

# Note "git gq doc ARG" shows only part of the documentation and is used for
# the web page generation.

SCRIPT_FULL_NAME=$(readlink -e "$0")
#MYDIR=$(dirname "$SCRIPT_FULL_NAME")
MYNAME=$(basename "$SCRIPT_FULL_NAME")

VERSION="1.1" #VERSION#

MYNAME_GIT="$(echo "$MYNAME" | sed -s 's/-/ /')"

QUEUENAME="default"
TOPPATCHDIR=".gqpatches"
PATCHDIR="$TOPPATCHDIR/$QUEUENAME"
APPLIEDDIR="$PATCHDIR/applied"
SERIESFILE="$PATCHDIR/series"
PARENTFILE="$PATCHDIR/parent"
QUEUEFILE="$TOPPATCHDIR/queue"

ALL_COMMANDS="abort applied backup bashcompletion change-order commands continue delete doc export fold glog goto help import init man new parent pop push qname record refresh restore show unapplied"

# shellcheck disable=SC2001
ALL_COMMANDS_RX=$(echo "$ALL_COMMANDS" | sed -e 's/ /|/g;s/^/^(/;s/$/)$/')

# general purpose return code variable:
rc=""

debug_opt=""
all_opt=""
no_add_opt=""
edit_opt=""
message_opt=""
file_opt=""
full_opt=""

rev_arg=""
name_arg=""
file_arg=""
dir_arg=""
doc_arg=""

list_arg=()

patchname=""

function print_doc {
    # $1: if empty, print complete text
    local part="$1"
    if [ -z "$part" ]; then
cat << EOF
======================================================
$MYNAME_GIT - patch queues for git
======================================================

EOF
    fi
    if [ -z "$part" ] || [ "$part" == "overview" ]; then
cat << EOF
Overview
--------

Patches vs. Commits
+++++++++++++++++++

git manages a repository with *commits*. A commit has the following properties:

- A state, this is the directory structure and the files and their contents and
  permissions.
- Metadata: log message, author and date
- A hash key that git uses internally to distinguish commits. Git hashes are
  calculated based on the contents of the files in the commit, the metadata of
  the commit (like timestamp and author), and the parent commit's hash.
- A predecessor commit unless it is the first commit in the repository
- A successor commit unless it is the head commit of a branch

For simplicity, we only consider a single branch for now. Then each commit has
exactly one or no predecessor and one or no successor.

All commits then form an ordered sequence like here::

  A --> B --> C --> D

A *patch* is the difference between two commits combined with the metadata of
the second patch.

So the commits A, B, C and D as shown above could also be represented as patches::

  (A-0) --> (B-A) --> (C-B) --> (D-C)

Here '(B-A)' means the difference of the files and directories of commits 'B'
and 'A'. '0' is the empty state before the very first commit where no files and
directories exist.

When you apply a patch to a commit you get the next commit::

  A + (B-A) = B

The patch queue
+++++++++++++++

The *patch queue* is a structure that contains patches outside of git. Patches
can be moved between the repository and the patch queue. Patches on the patch
queue are called *unapplied*, patches that are in the repository are called
*applied*.

In the following examples, the top of the repository and the patch queue is
always on the right side::

  Repository:  A --> B --> C --> D      Patch-Queue: <empty>
  applied: (A-0), (B-A), (C-B), (D-C)   unapplied: <none>

Now operation 'pop' moves a patch from the repository to the patch-queue::

  Repository:  A --> B --> C            Patch-Queue: (D-C)
  applied: (A-0), (B-A), (C-B)          unapplied: (D-C)

Another 'pop' moves the next patch from the repository to the patch-queue::

  Repository:  A --> B                  Patch-Queue: (D-C) --> (C-B)
  applied: (A-0), (B-A)                 unapplied: (D-C), (C-B)

Operation 'push' moves the top patch from the patch-queue back to the
repository::

  Repository:  A --> B --> C            Patch-Queue: (D-C)
  applied: (A-0), (B-A), (C-B)          unapplied: (D-C)

Advantages of the patch queue
+++++++++++++++++++++++++++++

The patch-queue is much more flexible than traditional commits:

- Patches can be reordered easily
- Patches can be combined ('fold')
- Patches can be updated ('refresh')
- Patches can replace development branches. You can put your local changes on
  the patch queue, run 'git pull' and put your patches back on the repository.
- Conflicts may occur but are usually easier to resolve than git merge
  conflicts

Disadvantages of the patch queue
++++++++++++++++++++++++++++++++

- moving a patch to the patch queue and back changes it's git hash key. This
  means you shouldn't apply this operation on patches that exist in other
  repositories. The definition of the *parent revision* ensures that you cannot
  do this by accident.
- changing the order of patches may lead to *conflicts*.
- Applying new commits in the repository while some patches are unapplied may
  lead to conflicts when the patches are applied later.

EOF
    fi
    if [ -z "$part" ] || [ "$part" == "implementation" ]; then
cat << EOF
Implementation
--------------

Patch files
+++++++++++

A *patch file* is basically a file with recipes for changes in files. Each
recipe is called a *hunk*. A *hunk* contains line numbers, context lines, lines
to remove and lines to add.

\`$MYNAME_GIT\` uses standard git commands to move patches between the
repository and the patch queue. In the patch queue, each patch is a file
created from the difference of a commit and it's predecessor in the repository
with \`git format-patch\`. Among the changes between two commits this file also
contains all the metadata of the second commit. The name of the patch file is
computed from the first line of the log message where spaces are replaced with
dashes and end with the extension '.patch'.

A patch file is re-applied to the repository with \`git am\`. 

Here is an example of a patch file::

  From 273c3709f7da0fe0e11369ea0d9a26053f78e3ee Mon Sep 17 00:00:00 2001
  From: Goetz Pfeiffer <goetzpf@googlemail.com>
  Date: Tue, 3 Jun 2025 18:45:57 +0200
  Subject: [PATCH] sample-comment
  
  ---
   sample.c | 2 +-
   1 file changed, 1 insertion(+), 1 deletion(-)
  
  diff --git a/sample.c b/sample.c
  index e5cf2b0..350c29b 100644
  --- a/sample.c
  +++ b/sample.c
  @@ -4,8 +4,8 @@ int main(int argc, char *argv[])
     {
       int i;
   
  -    printf("number of arguments: %d\n", argc);
       printf("program name: %s\n", argv[0]);
  +    /* iterate over all command line arguments: */
       for(i=1; i<argc; i++)
         printf("arg no %2d: %s\n", i, argv[i]);
       return 0;
  -- 
  2.49.0

The series file
+++++++++++++++

The order of patches is kept in a file named 'series' that just contains all
the filenames of all unapplied patches. This file is maintained by
\`$MYNAME_GIT\`.

Parent revision
+++++++++++++++

The parent revision is stored in a file 'parent'. This is the latest commit
that is not allowed to be modified. This file is usually created when you start
your work with \`$MYNAME_GIT init\`.

Multiple patch queues
+++++++++++++++++++++

Multiple patch queues are maintained in different directories. There is always
one patch queue active, it's name is stored in the file 'queue'.

EOF
    fi
    if [ -z "$part" ] || [ "$part" == "conflicts" ]; then
cat << EOF
Conflicts and conflict resolution
---------------------------------

Conflicts may happen when:

- you change the order of unapplied patches with \`$MYNAME_GIT change-order\`
  and then run \`$MYNAME_GIT push\`
- you unapply patches, make changes in the repository, e.g. \`git pull\` and
  then apply the patches again
- you combine unapplied patches with \`$MYNAME_GIT fold\` that are not in
  consecutive order

In the patch file example above, you see after '@@ -4,8 +4,8 @@' a single
*hunk*. The numbers are line numbers in the source file, here 'sample.c'.

All following lines that are indented with a single space are *context* lines.
Lines that start with a '-' character are to be removed, lines that start with
a '+' character are to be added.

A conflict occurs when the context lines or the lines to be removed couldn't be
found. In this case, a reject file is created.

Here are the messages you see in case of a conflict after you ran \`$MYNAME_GIT
push\`::

  $ ../../bin/git-gq push
  Applying: sample-comment
  Checking patch sample.c...
  error: while searching for:
    {
      int i;
  
      printf("number of arguments: %d\n", argc);
      printf("program name: %s\n", argv[0]);
      for(i=1; i<argc; i++)
        printf("arg no %2d: %s\n", i, argv[i]);
      return 0;
  
  error: patch failed: sample.c:4
  Applying patch sample.c with 1 reject...
  Rejected hunk #1.
  Patch failed at 0001 sample-comment
  hint: Use 'git am --show-current-patch=diff' to see the failed patch
  hint: When you have resolved this problem, run "git am --continue".
  hint: If you prefer to skip this patch, run "git am --skip" instead.
  hint: To restore the original branch and stop patching, run "git am --abort".
  hint: Disable this message with "git config set advice.mergeConflict false"
  Fix the change by looking at the *.rej files.
  Then run:
    git-gq continue
  To abort the operation without fixing run:
    git-gq abort

And here is the content of the reject file, 'sample.c.rej' in this case::

  diff a/sample.c b/sample.c	(rejected hunks)
  @@ -4,8 +4,8 @@ int main(int argc, char *argv[])
     {
       int i;
   
  -    printf("number of arguments: %d\n", argc);
       printf("program name: %s\n", argv[0]);
  +    /* iterate over all command line arguments: */
       for(i=1; i<argc; i++)
         printf("arg no %2d: %s\n", i, argv[i]);
       return 0;

In our example here, while the patch was moved to the patch queue, this line::

  printf("number of arguments: %d\n", argc);

had been changed to::

  printf("My number of arguments: %d\n", argc);

So the line to remove by the patch wasn't found and we had a conflict. If we
open both, the original file 'sample.c' and the reject file 'sample.c.rej' in
any text editor, we can easily see what the patch intended to do and apply the
changes manually.

This is called *resolving a conflict*. You have to go through all reject files,
there may be more than one and resolve all conflicts.

After you are finished, run::

  $MYNAME_GIT continue

This finishes the operation and tells git that the conflict was resolved. You
*must not* run \`git am continue\` yourself, \`$MYNAME_GIT continue\` already
does this for you.

If you cannot resolve conflicts because the reject files are too long or
complicated, you can abort the last command with::

  $MYNAME_GIT abort

In this case you may have to compare two versions of files and apply changes
directly.
EOF
    fi
    if [ -z "$part" ] || [ "$part" == "examples" ]; then
cat << EOF

Example Workflows
-----------------

Local development
+++++++++++++++++

Assuming you have cloned another git repository and want to start development
here. With \`$MYNAME_GIT\` you don't need to create a local branch. Just run::

  $MYNAME_GIT init

This sets up the \`$MYNAME_GIT\` directory and marks the current HEAD revision
as parent revision.

You can now begin to make changes. You create preliminary commits with::

  $MYNAME_GIT new NAME

where NAME should be a one line string with no spaces in it. This is a
preliminary log message that you can later update and extend. Every time you
make more changes you can either:

- run \`$MYNAME_GIT new\` to create a new commit
- run \`$MYNAME_GIT refresh\` to update the topmost commit
- run the \`git add..\` and \`git commit\` as usual to create a new commit

You can see what patches are applied with::

  $MYNAME_GIT applied

You can see what patches are unapplied with::

  $MYNAME_GIT unapplied

When you want to finalize your commits and update commit messages, first move
all of them as patches to the patch queue::

  $MYNAME_GIT pop -a

Then for each patch, to provide a proper log message, run::

  $MYNAME_GIT push
  $MYNAME_GIT refresh -e

You can also combine ('fold') an unapplied patch with::

  $MYNAME_GIT fold PATCH

Inspect the applied patches with::

  $MYNAME_GIT glog

When you are finished for all patches you can finalize these changes by setting
the parent version to the current HEAD version::

  $MYNAME_GIT parent HEAD

You are now ready to publish your patches.

Updates from a remote repository
++++++++++++++++++++++++++++++++

When you have created local patches and want to update your repository with new
patches from a remote repository, the usual way would be to run
\`git pull\` and then \`git merge\` or \`git rebase -i\`.

With the patch queue, there is now another way to handle this. Before pulling
patches from the public repository, put all your local changes on the patch
queue::

  $MYNAME_GIT pop -a

As a safety measure backup your patch queue with::

  $MYNAME_GIT backup

Now pull patches from the remote repository::

  git pull

Reset the parent revision to the new repository HEAD::

  $MYNAME_GIT parent HEAD

Finally re-apply all your patches::

  $MYNAME_GIT push -a

If you get messages about conflicts ("rejects") you have to resolve them. See
further above at "Conflicts and conflict resolution".

This workflow allows to resolve conflicts step by step which is usually easier
than resolving all conflicts that arise from \`git pull\` all at once. Also the
reject files created for each conflict clearly show which change was intended
at the patch which is usually easier than the common 3-way merge.

EOF
    fi
    if [ -z "$part" ] || [ "$part" == "commandline" ]; then
cat << EOF
Command line interface
----------------------
EOF
short_help_text
    fi
}

function print_short_help {
    # print short help without reStructuredText underlines:
    short_help_text | grep -v '^+\+$'
}

function unique_patch_name {
    # generate a patchname that doesn't already exist
    # $1: name of patch file
    local CNT
    local TEMP_PATCHNAME
    local PATCHNAME
    PATCHNAME="$1"
    if [ ! -e "$PATCHDIR/$PATCHNAME" ]; then 
        echo "$PATCHNAME"
        return
    fi
    CNT=1
    while true; do
        TEMP_PATCHNAME="$(printf "%04d-%s" "$CNT" "$PATCHNAME")"
        if [ ! -e "$PATCHDIR/$TEMP_PATCHNAME" ]; then
            break
        fi
        CNT=$((CNT+1))
    done
    echo "$TEMP_PATCHNAME"
}

function prepend_seriesfile {
    # prepend a filename to the series file
    # $1: filename
    if [ ! -s "$SERIESFILE" ]; then
        echo "$1" > "$SERIESFILE"
    else
        # insert at first line
        sed -i "1i$1" "$SERIESFILE"
    fi
}

function git_goto_repo_dir {
    # returns: 
    #   0 : no error
    #   1 : fatal error
    # in case of an error, the function prints an error message to stderr.
    while [ "$(pwd)" != "/" ]; do
        if [ -d ".git" ]; then
            break;
        fi
        if ! cd ..; then
            echo "Error, 'cd ..' failed" >&2
            return 1
        fi
    done
    if [ ! -d ".git" ]; then
        echo "error, '.git' not found" >&2
        return 1
    fi
    return 0
}

function git_check_exists {
    # $1: revision
    # checks if revision exists
    # returns: 
    #   0 : revision exists
    # 128 : revision does not exist
    git cat-file  -e "$1"  2> /dev/null
}

function log_template {
    # create a template file for a log message
    # $1: direct log message
    # $2: file with log message
    # $3: file to create
    # $4: if non zero, add preamble
    rm -f "$3"
    touch "$3"
    if [ -n "$4" ]; then
        echo "*** Please review and change this log message" >> "$3"
    fi
    if [ -n "$1" ]; then
        echo "$1" >> "$3"
    fi
    if [ -n "$2" ]; then
        cat "$2" >> "$3"
    fi
}

function git_head_full_log {
    # create file with HEAD log message.
    # $1: filename to create
    # $2: if non-zero, put preamble in the first line
    rm -f "$1"
    touch "$1"
    if [ -n "$2" ]; then
        echo "*** Please review and change this log message" >> "$1"
    else
        git log --format=%B -1 >> "$1"
    fi
}

function git_oneline_log {
    # $1: revision spec
    # prints one-line log, possible with color, to the console
    # GIT_PAGER=cat: do not use pager
    # shellcheck disable=SC2209
    GIT_PAGER=cat git log --color=auto --oneline "$1"
}

function git_oneline_log_single {
    # $1: revision spec
    # prints one-line log, possible with color, to the console
    # GIT_PAGER=cat: do not use pager
    # shellcheck disable=SC2209
    GIT_PAGER=cat git log --color=auto --oneline -1 "$1"
}

function git_mk_changes_files {
    # $1: if empty create only DIFF.patch
    #     if non-empty create DIFF.patch and HEAD.patch
    # create files:
    # $TOPPATCHDIR/HEAD.patch : all changes of the HEAD patch
    # $TOPPATCHDIR/DIFF.patch : all changes in the working copy not yet
    #                           comitted
    git diff --cached > "$TOPPATCHDIR/DIFF.patch"
    if [ -n "$1" ]; then
        git show HEAD > "$TOPPATCHDIR/HEAD.patch"
    fi
}

function git_rm_changes_files {
    # removes the 2 files:
    # $TOPPATCHDIR/HEAD.patch
    # $TOPPATCHDIR/DIFF.patch
    rm -f "$TOPPATCHDIR/HEAD.patch" "$TOPPATCHDIR/DIFF.patch"
}

function get_parent {
    # returns: 
    #   0 : no error
    #   1 : fatal error
    # in case of an error, the function prints an error message to stderr.
    local PARENT
    if [ ! -s "$PARENTFILE" ]; then
        echo "Error, $PARENTFILE does not exist or is empty" >&2
        return 1
    fi
    PARENT="$(cat "$PARENTFILE")"
    if ! git_check_exists "$PARENT"; then
        echo "Error, parent revision $PARENT doesn't exist in repository" >&2
        return 1
    fi
    echo "$PARENT"
    return 0
}

function find_single_unapplied_patch {
    # $1: regexp
    # finds a unique unapplied patch
    # returns: 
    #   0 : no error
    #   1 : fatal error
    # in case of an error, the function prints an error message to stderr.
    local MATCHES
    if [ ! -e "$SERIESFILE" ]; then
        echo "Error, series file $SERIESFILE doesn't exist." >&2
        return 1
    fi
    if [ ! -s "$SERIESFILE" ]; then
        echo "Error, there are no unapplied patches." >&2
        return 1
    fi
    MATCHES="$(grep -c "$1" "$SERIESFILE")"
    if [ "$MATCHES" -eq 0 ]; then
        echo "Error, no patches match '$1'." >&2
        return 1
    fi
    if [ "$MATCHES" -ne 1 ]; then
        echo "Error, multiple patches match '$1'." >&2
        return 1
    fi
    grep "$1" "$SERIESFILE"
}

function find_first_unapplied_patch {
    # $1: regexp
    # finds unapplied patch
    # returns:
    #  the patch
    #    - or -
    #  an empty string
    if [ ! -e "$SERIESFILE" ]; then
        echo ""
        return
    fi
    grep "$1" "$SERIESFILE" | head -n 1
}

function find_first_applied_patch {
    # $1: regexp
    # finds applied patch, returns hash key
    # returns: 
    #   0 : no error
    #   1 : fatal error
    # in case of an error, the function prints an error message to stderr.
    local START
    local PARENT
    PARENT=$(get_parent)
    rc="$?"
    if [ "$rc" -ne 0 ]; then
        return "$rc"
    fi
    START="${PARENT}.."
    git log --oneline "$START" | grep "$1" | head -n 1 | sed -e 's/ .*//'
}

function git_rev_parse {
    # runs git rev-parse on $1
    #   0 : no error
    #   1 : fatal error
    # in case of an error, the function prints an error message to stderr.
    local REV
    REV="$(git rev-parse --short "$1")"
    rc="$?"
    if [ "$rc" -ne 0 ]; then
        # git rev-parse already printed an error message
        return "$rc"
    fi
    echo "$REV"
}

function git_head_revision {
    # returns revision of HEAD
    git rev-parse --short HEAD
}

function find_head_patch {
    # $1: regexp
    # looks if the HEAD patch matches pattern
    # returns:
    #   hash key
    git log --oneline -1 | grep "$1" | sed -e 's/ .*//'
}

function dump_patch_file {
    # $1: file
    # test if we have a terminal:
    if [ -t 1 ]; then
        colordiff < "$1" | less -R
    else
        cat "$1"
    fi
}

function git_head_log {
    # Get the pure log message of the HEAD patch.
    # print to stdout
    git log -1 --pretty=%B 
}

function git_add_changes {
    # add only changed files to stash
    # $1: if not zero, add unknown files, too
    #
    # Does not add:
    # - unknown files (depending on $1)
    # - all files starting with $TOPPATCHDIR
    # - all files ending with '.rej'
    # - renames: the old files that are removed, these are already in git stash
    # sample output from git --porcelain:
    #  M bin/git-gq
    #  M test/Makefile
    #  M test/TESTS
    # RM test/git_gq_dump.ok -> test/git_gq_show.ok
    # RM test/git_gq_dump.sh -> test/git_gq_show.sh
    # ?? .gqpatches-2025-06-07T172509.tgz
    # ?? .gqpatches/
    local EXTRA
    # a bash array is the correct way to provide several extra arguments to a
    # command:
    EXTRA=()
    if [ -z "$1" ]; then
        # do not show unknown files:
        EXTRA+=("-uno")
    fi
    local LINES
    git status --porcelain "${EXTRA[@]}" | sed -e 's/^RM .*-> //' | sed -e 's/^.. //' | grep -v "\(^${TOPPATCHDIR}[/-]\|\.rej$\)" |xargs git add
}

function git_select_changes {
    # Interactively select files to add to stash.
    git add --patch
}

function git_amend {
    # simple amend of HEAD revision
    # $1: if not empty, take log message from this file
    # $2: if not empty, take log message from $1 as a template the 
    #     user has to edit
    local EXTRA
    # a bash array is the correct way to provide several extra arguments to a
    # command:
    EXTRA=()
    if [ -n "$2" ]; then
        EXTRA+=("-t" "$1")
    elif [ -n "$1" ]; then
        EXTRA+=("-F" "$1")
    fi
    git commit --amend "${EXTRA[@]}"
}

function save_applied_patches {
    # save all applied patches
    # returns: 
    #   0 : no error
    #   1 : fatal error
    # in case of an error, the function prints an error message to stderr.
    local PARENT
    local rev
    PARENT=$(get_parent)
    rc="$?"
    if [ "$rc" -ne 0 ]; then
        return "$rc"
    fi
    rev=$(git_head_revision)
    rm -rf "$APPLIEDDIR"
    if [ "$rev" != "$PARENT" ]; then
        mkdir -p "$APPLIEDDIR"
        git format-patch -o "$APPLIEDDIR" "$PARENT.."
    fi
}

function del_applied_patches {
    rm -rf "$APPLIEDDIR"
}

function select_queue {
    # $1: queue name
    # modifies global variables: QUEUENAME, PATCHDIR, SERIESFILE,
    #                            PARENTFILE
    QUEUENAME="$1"
    PATCHDIR="$TOPPATCHDIR/$QUEUENAME"
    APPLIEDDIR="$PATCHDIR/applied"
    SERIESFILE="$PATCHDIR/series"
    PARENTFILE="$PATCHDIR/parent"
}

function qpop_check {
    # returns: 
    #   0 : no error, qpop is not beyond parent
    #   1 : qpop is not allowed
    #   2 : fatal error
    #   3 : fatal error, git has started tracking $TOPPATCHDIR
    #       'git gq pop' would remove the .gqpatches directory itself
    # in case of a fatal error, the function prints an error message to stderr.
    local rev
    local PARENT
    if git show HEAD --stat | grep -q "^ ${TOPPATCHDIR}[/-]"; then
        echo "FATAL Error, somehow git is tracking $TOPPATCHDIR." >&2
        echo "'$MYNAME_GIT pop' would remove $TOPPATCHDIR." >&2
        echo "Do the following to fix this:" >&2
        echo "  git reset HEAD~1 ${TOPPATCHDIR}*" >&2
        echo "  git commit -C HEAD --amend" >&2
        return 3
    fi
    PARENT=$(get_parent)
    rc="$?"
    if [ "$rc" -ne 0 ]; then
        return 2
    fi
    rev=$(git_head_revision)
    if [ "$PARENT" == "$rev" ]; then
        return 1
    fi
    return 0
}

function qpop_one {
    # do a single 'qpop' operation.
    local ORIG_PATCHNAME
    local PATCHNAME
    local TEMP_PATCHNAME
    local CNT
    ORIG_PATCHNAME=$(git format-patch -o "$TOPPATCHDIR" -1 HEAD | sed -e "s#^$TOPPATCHDIR/##")
    # remove leading number from patchname:
    # shellcheck disable=SC2001
    PATCHNAME=$(echo "$ORIG_PATCHNAME"  | sed -e 's/^[0-9]\+-//')
    # generate a unique name for the file:
    PATCHNAME="$(unique_patch_name "$PATCHNAME")"
    mv "$TOPPATCHDIR/$ORIG_PATCHNAME" "$PATCHDIR/$PATCHNAME"
    prepend_seriesfile "$PATCHNAME"
    git reset --hard HEAD~1
}

function qpush_specified {
    # $1: name of patch
    # returns: 
    #   0 : no error
    #   1 : fatal error
    # in case of an error, the function prints an error message to stderr.
    local PATCHNAME
    PATCHNAME=$(find_single_unapplied_patch "$1")
    rc="$?"
    if [ "$rc" -ne 0 ]; then
        return "$rc"
    fi
    echo "$PATCHNAME" > "$PATCHDIR/PUSH"
    # remove PATCHNAME from SERIESFILE:
    grep -v -F "$PATCHNAME" "$SERIESFILE" > "$SERIESFILE.new"
    if ! git am --reject "$PATCHDIR/$PATCHNAME"; then
        echo "The patch to be folded could not be applied." >&2
        echo "Fix the change by looking at the *.rej files." >&2
        echo "Then run:" >&2
        echo "  $MYNAME continue" >&2
        echo "To abort the operation without fixing run:" >&2
        echo "  $MYNAME abort" >&2
        return 1
    fi
    rm -f "$PATCHDIR/$PATCHNAME" "$PATCHDIR/PUSH" "$SERIESFILE" && mv "$SERIESFILE.new" "$SERIESFILE"
}

function qpush_one {
    # do a single 'qpush' operation.
    # returns: 
    #   0 : no error
    #   1 : fatal error
    # in case of an error, the function prints an error message to stderr.
    local PATCHNAME
    if [ ! -s "$SERIESFILE" ]; then
        echo "Error, all patches in queue are already applied." >&2
        return 1
    fi
    PATCHNAME=$(head -n 1 "$SERIESFILE")
    echo "$PATCHNAME" > "$PATCHDIR/PUSH"
    # remove PATCHNAME from SERIESFILE:
    cp -a "$SERIESFILE" "$SERIESFILE.new" && sed -i -e '1d' "$SERIESFILE.new"
    if ! git am --reject "$PATCHDIR/$PATCHNAME"; then
        echo "Fix the change by looking at the *.rej files." >&2
        echo "Then run:" >&2
        echo "  $MYNAME continue" >&2
        echo "To abort the operation without fixing run:" >&2
        echo "  $MYNAME abort" >&2
        return 1
    fi
    rm -f "$PATCHDIR/$PATCHNAME" "$PATCHDIR/PUSH" "$SERIESFILE" && mv "$SERIESFILE.new" "$SERIESFILE"
}

function qdelete {
    # $1: name of patch to delete
    # returns: 
    #   0 : no error
    #   1 : fatal error
    # in case of an error, the function prints an error message to stderr.
    local name
    local patchname
    name="$1"
    patchname=$(find_single_unapplied_patch "$name")
    rc="$?"
    if [ "$rc" -ne 0 ]; then
        return "$rc"
    fi
    rm "$PATCHDIR/$patchname"
    if [ -s "$SERIESFILE" ]; then
        cp -a "$SERIESFILE" "$SERIESFILE.bak" && grep -v -F -e "$patchname" "$SERIESFILE.bak" > "$SERIESFILE" && rm -f "$SERIESFILE.bak;"
    fi
}

function create_parentfile {
    # $1: revision
    #   0 : no error
    #   1 : fatal error
    # in case of an error, the function prints an error message to stderr.
    local rev
    rev=$(git rev-parse --short "$1")
    # shellcheck disable=SC2181
    if [ $? -ne 0 ]; then
        echo "Error, invalid revision: $1" >&2
        return 1
    fi
    if [ "$1" == "$rev" ]; then
        echo "queue parent revision set to $1"
    else
        echo "queue parent revision set to $1 ($rev)"
    fi
    echo "$rev" > "$PARENTFILE"
}

function short_help_text {
cat << EOF
$MYNAME : handle git patch queues

usage: $MYNAME_GIT COMMAND [OPTIONS]

Bash completion commands
++++++++++++++++++++++++

  commands       
    List all known commands on the console

  bashcompletion 
    List the line you have to add to your .bashrc
    to integrate completion into the 'git' command.

Queue management commands
+++++++++++++++++++++++++

  init [QNAME [REV]]
    Create/select a patch queue with name 'QNAME'. QNAME is optional, the
    default patch queue name is 'default'. If 'REV' is given this is the parent
    revision, if it is not givem, 'HEAD' is taken as the parent. You must run
    this command once to initialize the patch queue in your repository.

  qname [QNAME]   
    If QNAME is not given, show current patch queue name. if QNAME is given,
    change to patch queue QNAME. If the patch queue QNAME is created for the
    first time, the parent revision is set to your 'HEAD' revision. If this is
    not intended, you may change this with \`$MYNAME_GIT parent REVISION\` to
    another revision.

  backup         
    Create backup tar file of patch directory '$TOPPATCHDIR'.

  restore FILE   
    Restore patch directory from a backup file. '$TOPPATCHDIR'.

  change-order   
    Call an editor to edit the file that contains all currently unapplied
    patches. Note the the patches in the file are applied from top to bottom.

  applied    
    Show all applied patches up to parent+1.

  unapplied      
    Show all patches of the patch queue.

  parent [REVISION}   
    Set REVISION as patch queue parent revision. Do never go beyond this
    revision with pop. Use 'HEAD' to set your repository HEAD as parent
    revision. If HEAD is not given, show the current parent revision.

  export DIRECTORY
    Create numbered patch files from all currently applied patches in
    DIRECTORY. The numbers are in the order of patches from bottom to top.
    DIRECTORY must exist.

  import PATCHFILE [PATCHFILE...]
    Import a number of patchfiles to the patch queue. The last patchfile in the
    list will be on the top of the queue. Note that the patch files must have
    been generated with \`git format-patch\` or \`$MYNAME_GIT pop\`. This
    cannot be used for patches generated with the \`patch\` program. These you
    have to apply with \`git apply PATCHFILE\`.

Patch management commands
+++++++++++++++++++++++++

  new [NAME]     
    Create new patch (commit) with log-message NAME. NAME is meant as a
    preliminary commit message, it should be a single line without spaces. If
    NAME is omitted, you can enter a complete log message interactively.

  record [NAME]  
    Interactively select changes for a new patch (commit with log-message NAME)

  refresh        
    Update the topmost patch.

  pop            
    Pop the topmost patch.

  push           
    Apply the top patch from the patch queue.

  goto NAME|REGEXP
    Do push or pop until the specified patch is the latest applied patch.

  fold NAME|REGEXP
    Fold patch 'NAME' to the topmost patch. Patch 'NAME' must not be appled
    already. Note that the log message of the fold-patch is appended to the
    existing log message. You may change the log message with \`$MYNAME_GIT
    refresh -e\`.

  delete NAME|REGEXP
    Delete unapplied patch with given name.

  show NAME|REGEXP
    Show changes of an applied or unapplied patch on the console.

  continue       
    Continue 'push' after you had a conflict and had it fixed manually.

  abort          
    Abort (undo) 'push' after you had a conflict and could not fix it manually.

Miscellaneous commands
++++++++++++++++++++++

  help           
    Show this help.

  doc            
    Show reStructuredText source of man page.

  man            
    Show man page.

  glog
    Graphical log, display all commits and branches as a tree on the console.

OPTIONS
+++++++

  -h --help
    Show help.

  -H --HELP
    Show help without pager.

  -v --version
    Show version and exit.

  -D --debug
    Run the script with "set -x" which shows what it does.

  -a --all
    push/pop: apply on ALL patches.

  -N --no-add
    new/refresh/fold: DO NOT add all modified changes to patch.
    continue: DO NOT add all modified and unknown changes to patch

  -e --edit
    refresh/fold: start editor to edit log message

  -m --message MESSAGE
    refresh: use MESSAGE as log message

  -F --file FILE
    refresh: take log message from FILE.

  -L --full
    restore: do also restore all patches that were applied when the backup was
    created. Caution: This runs \`git checkout PARENT\` and \`git am\` on your
    repository.
EOF
}

function pager_help {
    if less -V >/dev/null 2>&1; then
        # use less pager for help:
        $SCRIPT_FULL_NAME --HELP | less
    else
        print_short_help
    fi
}

function manpage {
    # display man page generated with rst2man
    if ! rst2man --version > /dev/null; then
        echo "rst2man not found, display reStructuredText instead." >&2
        if less -V >/dev/null 2>&1; then
            # use less pager for help:
            $SCRIPT_FULL_NAME doc | less
        else
            print_doc ""
        fi
    else
        $SCRIPT_FULL_NAME doc | rst2man | man -l -
    fi
}

declare -a ARGS
skip_options=""

while true; do
    case "$1" in
        -h | --help)
            pager_help
            exit 0
            ;;
        -H | --HELP)
            print_short_help
            exit 0
            ;;
        -a | --all)
            all_opt="yes"
            shift
            ;;
        -N | --no-add)
            no_add_opt="yes"
            shift
            ;;
        -L | --full)
            full_opt="yes"
            shift
            ;;
        -e | --edit)
            edit_opt="yes"
            shift
            ;;
        -m | --message)
            message_opt="$2"
            shift 2
            ;;
        -F | --file)
            file_opt="$2"
            shift 2
            ;;
        -D | --debug)
            debug_opt="yes"
            shift
            ;;
        -v | --version)
            echo "$MYNAME $VERSION"
            exit 0
            ;;
        -- )
            skip_options="yes"
            shift;
            break
            ;;
        *)
            if [ -z "$1" ]; then
                break;
            fi
            if [[ $1 =~ ^- ]]; then
                echo "unknown option: $1"
                exit 1
            fi
            ARGS+=("$1")
            shift
            ;;
    esac
done

if [ -n "$skip_options" ]; then
    while true; do
        if [ -z "$1" ]; then
            break;
        fi
        ARGS+=("$1")
        shift
    done
fi

COMMAND=""

for arg in "${ARGS[@]}"; do
    # examine extra args
    # match known args here like:
    # if [ "Â§arg" == "doit" ]; then ...
    #     continue
    # fi
    if [ "$COMMAND" == "import" ]; then
        list_arg+=("$arg")
        continue
    fi
    if [ "$COMMAND" == "restore" ]; then
        if [ -n "$file_arg" ]; then
            echo "unexpected: '$arg'" >&2
            exit 1
        fi
        file_arg="$arg"
        continue
    fi
    if [ "$COMMAND" == "export" ]; then
        if [ -n "$dir_arg" ]; then
            echo "unexpected: '$arg'" >&2
            exit 1
        fi
        dir_arg="$arg"
        continue
    fi
    if [ "$COMMAND" == "doc" ]; then
        if [ -n "$doc_arg" ]; then
            echo "unexpected: '$arg'" >&2
            exit 1
        fi
        doc_arg="$arg"
        continue
    fi
    if [ "$COMMAND" == "parent" ]; then
        if [ -n "$rev_arg" ]; then
            echo "unexpected: '$arg'" >&2
            exit 1
        fi
        rev_arg="$arg"
        continue
    fi
    if [[ "$COMMAND" == "init" ]]; then
        if [ -z "$name_arg" ]; then
            name_arg="$arg"
            continue
        fi
        if [ -z "$rev_arg" ]; then
            rev_arg="$arg"
            continue
        fi
        echo "unexpected: '$arg'" >&2
        exit 1
    fi
    if [[ "$COMMAND" =~ qname|fold|goto|new|record|delete|show ]]; then
        if [ -n "$name_arg" ]; then
            echo "unexpected: '$arg'" >&2
            exit 1
        fi
        name_arg="$arg"
        continue
    fi
    if [[ "$arg" =~ $ALL_COMMANDS_RX ]]; then
        if [ -n "$COMMAND" ]; then
            echo "unexpected: '$arg'" >&2
            exit 1
        fi
        COMMAND="$arg"
        continue
    fi
    echo "Error, unexpected command: '$arg'." >&2
    exit 1
done

if [ -n "$debug_opt" ]; then
    set -x
fi

if [ -z "$COMMAND" ] || [ "$COMMAND" == "help" ]; then
    manpage
    exit 0
fi

if [ "$COMMAND" == "doc" ]; then
    print_doc "$doc_arg"
    exit 0
fi

if [ "$COMMAND" == "man" ]; then
    manpage
    exit 0
fi

if [ "$COMMAND" == "commands" ]; then
    echo -n "$ALL_COMMANDS"
    exit 0
fi

if [ "$COMMAND" == "bashcompletion" ]; then
    # shellcheck disable=SC2016
    echo '_git_gq() { __gitcomp "$(git-gq commands)" "" "$cur"; }'
    exit 0
fi

if [ "$COMMAND" == "glog" ]; then
    git log --graph --all --decorate
    exit 0
fi

if [ -n "$file_arg" ]; then
    if [ ! -e "$file_arg" ]; then
        echo "Error, file $file_arg doesn't exist." >&2
        exit 1
    fi
    # convert 'file_arg' to an absolute path:
    file_arg="$(readlink -e "$file_arg")"
fi

if [ -n "$dir_arg" ]; then
    if [ ! -d "$dir_arg" ]; then
        echo "Error, directory '$dir_arg' doesn't exist." >&2
        exit 1
    fi
    # convert 'dir_arg' to an absolute path:
    dir_arg="$(readlink -e "$dir_arg")"
fi

if ! git_goto_repo_dir; then
    exit $?
fi

if [ "$COMMAND" == "restore" ]; then
    if [ -d "$TOPPATCHDIR" ]; then
        echo "$TOPPATCHDIR already exists, is it okay to rename it to"
        date_=$(date '+%Y-%m-%dT%H%M%S')
        echo "$TOPPATCHDIR-$date_ ?"
        read -p "Enter 'y' or 'Y' to continue, everything else aborts " -n 1 -r
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 1
        fi
        mv "$TOPPATCHDIR" "$TOPPATCHDIR-$date_"
    fi
    tar -xzf "$file_arg"
    QUEUENAME=$(cat "$QUEUEFILE")
    select_queue "$QUEUENAME"
    PARENT=$(get_parent)
    rc="$?"
    if [ "$rc" -ne 0 ]; then
        exit "$rc"
    fi
    if [ -n "$full_opt" ] && [ -d "$APPLIEDDIR" ]; then
        echo "Restore originally applied patches in repository ?"
        read -p "Enter 'y' or 'Y' to make changes, everything else skips this " -n 1 -r
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            # git reset --hard "$PARENT"
            git checkout "$PARENT"
            if [ -d "$APPLIEDDIR" ]; then
                # all patches here have a preceeding number and should already
                # have the right order by this.
                # shellcheck disable=SC2086
                git am $APPLIEDDIR/*.patch
            fi
            del_applied_patches
        else
            echo "Originally applied patches are in $APPLIEDDIR"
        fi
    fi
    exit 0
fi

if [ "$COMMAND" == "init" ]; then
    if [ -n "$name_arg" ]; then
        QUEUENAME="$name_arg"
    fi
    mkdir -p "$TOPPATCHDIR"
    if [ -d "$TOPPATCHDIR/$QUEUENAME" ]; then
        echo "Error, patch queue $QUEUENAME already exists" >&2
        exit 1
    fi
    echo "$QUEUENAME" > "$QUEUEFILE"
    select_queue "$QUEUENAME"
    mkdir -p "$TOPPATCHDIR/$QUEUENAME"
    if [ -z "$rev_arg" ]; then
        rev_arg="HEAD"
    fi
    if ! create_parentfile "$rev_arg"; then
        exit 1
    fi
    exit 0
fi

if [ ! -d "$TOPPATCHDIR" ]; then
    echo "please run '$MYNAME_GIT init' first." >&2
    exit 1
fi

if [ "$COMMAND" == "qname" ]; then
    if [ -z "$name_arg" ]; then
        QUEUENAME=$(cat "$QUEUEFILE")
        echo "Existing queues:"
        (cd $TOPPATCHDIR && find . -type d | grep -v '^\.$' | sed -e 's#^\./#\t#')
        echo
        echo "Currently selected:"
        echo -e "\t$QUEUENAME"
        exit 0
    else
        QUEUENAME="$name_arg"
        echo "$QUEUENAME" > "$QUEUEFILE"
        select_queue "$QUEUENAME"
        if [ ! -d "$TOPPATCHDIR/$QUEUENAME" ]; then
            mkdir -p "$TOPPATCHDIR/$QUEUENAME"
            if ! create_parentfile HEAD; then
                exit 1
            fi
        fi
    fi
    exit 0
fi

QUEUENAME=$(cat "$QUEUEFILE")
select_queue "$QUEUENAME"
if [ ! -d "$PATCHDIR" ]; then
    echo "error: $PATCHDIR does not exist" >&2
    exit 1
fi

if [ "$COMMAND" == "backup" ]; then
    if ! save_applied_patches; then
        exit $?
    fi
    date_=$(date '+%Y-%m-%dT%H%M%S')
    tar -czf "$TOPPATCHDIR-$date_.tgz" "$TOPPATCHDIR"
    del_applied_patches
    exit 0
fi

if [ "$COMMAND" == "change-order" ]; then
    editor="$EDITOR"
    if [ -z "$EDITOR" ]; then
        editor="$VISUAL"
    fi
    if [ -z "$EDITOR" ]; then
        echo "Caution: No default editor is specified in environment "
        echo "variables 'EDITOR' and 'VISUAL'."
        echo "Use 'vi' instead ?"
        echo "Note that you can always abort editing in 'vi' with"
        echo "  <ESC> :qa!"
        read -p "Enter 'y' or 'Y' to continue, everything else aborts " -n 1 -r
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 1
        fi
        editor="vi"
    fi
    $editor "$SERIESFILE"
    exit 0
fi

if [ "$COMMAND" == "export" ]; then
    if [ -z "$dir_arg" ]; then
        echo "Error, DIRECTORY missing." >&2
        exit 1
    fi
    PARENT=$(get_parent)
    rc="$?"
    if [ "$rc" -ne 0 ]; then
        exit "$rc"
    fi
    START="${PARENT}.."
    git format-patch -o "$dir_arg" "$START"
    exit 0
fi

if [ "$COMMAND" == "import" ]; then
    if (( ${#list_arg[@]} == 0 )); then
        echo "Error, PATCHFILE(s) missing." >&2
        exit 1
    fi
    for file_ in "${list_arg[@]}"; do
        if [ ! -e "$file_" ]; then
            echo "Error, file '$file_' not found." >&2
            exit 1
        fi
    done
    for file_ in "${list_arg[@]}"; do
        new_="$(unique_patch_name "$(basename "$file_")")"
        cp -a "$file_" "$PATCHDIR/$new_"
        prepend_seriesfile "$new_"
    done
    exit 0
fi

if [ "$COMMAND" == "parent" ]; then
    if [ -z "$rev_arg" ]; then
        if [ ! -s "$PARENTFILE" ]; then
            echo "no PARENT revision defined"
        else
            PARENT=$(get_parent)
            rc="$?"
            if [ "$rc" -ne 0 ]; then
                exit "$rc"
            fi
            git_oneline_log_single "$PARENT"
        fi
        exit 0
    fi
    if ! create_parentfile "$rev_arg"; then
        exit 1
    fi
    exit 0
fi

if [ "$COMMAND" == "new" ]; then
    if [ -z "$no_add_opt" ]; then
        # "": do not add unknown files:
        git_add_changes ""
    fi
    if [ -n "$name_arg" ]; then
        # shellcheck disable=SC2089
        name_opt=("-m" "$name_arg")
    else
        # if this case an editor will (probably) be started
        name_opt=()
        # create .gqpatches/DIFF.patch so the user can review changes while
        # editing the log message:
        git_mk_changes_files ""
    fi
    git commit "${name_opt[@]}"
    if [ -z "$name_arg" ]; then
        # remove the changes files:
        git_rm_changes_files
    fi
    exit 0
fi

if [ "$COMMAND" == "record" ]; then
    git_select_changes
    # a bash array is the correct way to provide several extra arguments to a
    # command:
    EXTRA=()
    if [ -n "$name_arg" ]; then
        EXTRA=("-m" "$name_arg")
    fi
    git commit "${EXTRA[@]}"
    exit 0
fi

if [ "$COMMAND" == "refresh" ]; then
    if [ -z "$message_opt" ] && [ -z "$file_opt" ]; then
        git_head_full_log "$PATCHDIR/LOG" "$edit_opt"
    else
        log_template "$message_opt" "$file_opt" "$PATCHDIR/LOG" "$edit_opt" 
    fi
    if [ -z "$no_add_opt" ]; then
        # "": do not add unknown files:
        git_add_changes ""
    fi
    if [ -n "$edit_opt" ]; then
        # create two files so the user can review changes while editing the
        # log message:
        git_mk_changes_files "both"
    fi
    git_amend "$PATCHDIR/LOG" "$edit_opt"
    if [ -n "$edit_opt" ]; then
        # remove the changes files:
        git_rm_changes_files
    fi
    rm -f "$PATCHDIR/LOG"
    exit 0
fi

if [ "$COMMAND" == "delete" ]; then
    if [ -z "$name_arg" ]; then
        echo "error, patchname is missing" >&2
        exit 1
    fi
    if ! qdelete "$name_arg"; then
        exit 1
    fi
    exit 0
fi

if [ "$COMMAND" == "pop" ]; then
    while true; do
        qpop_check
        rc="$?"
        if [ "$rc" -eq 3 ] || [ "$rc" -eq 2 ]; then
            exit "$rc"
        fi
        if [ "$rc" -eq 1 ]; then
            if [ -z "$all_opt" ]; then
                echo "Error, 'pop' beyond parent revision not allowed." >&2
                exit 1
            fi
            break
        fi
        qpop_one
        if [ -z "$all_opt" ]; then
            break
        fi
    done
    exit 0
fi

if [ "$COMMAND" == "push" ]; then
    while true; do
        if ! qpush_one; then
            exit 1
        fi
        if [ -z "$all_opt" ]; then
            break
        else
            # with "--all", reaching the end is no error:
            if [ ! -s "$SERIESFILE" ]; then
                break
            fi
        fi
    done
    exit 0
fi

if [ "$COMMAND" == "goto" ]; then
    if [ -z "$name_arg" ]; then
        echo "error, patchname is missing" >&2
        exit 1
    fi
    patchname=$(find_first_unapplied_patch "$name_arg")
    if [ -n "$patchname" ]; then
        while true; do
            if ! qpush_one; then
                exit 1
            fi
            if [ -z "$(find_first_unapplied_patch "$patchname")" ]; then
                break
            fi
        done
        exit 0
    fi
    patchname=$(find_first_applied_patch "$name_arg")
    rc="$?"
    if [ "$rc" -ne 0 ]; then
        exit "$rc"
    fi
    if [ -n "$patchname" ]; then
        while [ -z "$(find_head_patch "$patchname")" ]; do
            qpop_one
        done
        exit 0
    fi
    echo "Error, patch '$name_arg' not found."
    exit 1
fi

if [ "$COMMAND" == "fold" ]; then
    if [ -z "$name_arg" ]; then
        echo "error, patchname is missing" >&2
        exit 1
    fi
    if [ ! -e "$PATCHDIR/$name_arg" ]; then
        patchname=$(find_single_unapplied_patch "$name_arg")
        rc="$?"
        if [ "$rc" -ne 0 ]; then
            exit "$rc"
        fi
        name_arg="$patchname"
    fi
    git_head_full_log "$PATCHDIR/LOG" "$edit_opt"
    echo -e '\n***\n' >> "$PATCHDIR/LOG"
    if ! qpush_specified "$name_arg"; then
        exit 1
    fi
    git_head_log >> "$PATCHDIR/LOG"
    qpop_one
    git apply "$PATCHDIR/$name_arg"
    if [ -z "$no_add_opt" ]; then
        # "": do not add unknown files:
        git_add_changes ""
    fi
    if [ -n "$edit_opt" ]; then
        # create two files so the user can review changes while editing the
        # log message:
        git_mk_changes_files "both"
    fi
    # if $edit_opt is not empty, git_amend will start an editor to edit the
    # combination of both log messages:
    git_amend "$PATCHDIR/LOG" "$edit_opt"
    if [ -n "$edit_opt" ]; then
        # remove the changes files:
        git_rm_changes_files
    fi
    rm -f "$PATCHDIR/LOG"
    qdelete "$name_arg"
    echo "Note: Log messages were combined into one"
    exit 0
fi

if [ "$COMMAND" == "show" ]; then
    patchname="$name_arg"
    if [ -e "$PATCHDIR/$patchname" ]; then
        dump_patch_file "$PATCHDIR/$patchname"
        exit 0
    fi
    patchname="$(find_first_unapplied_patch "$name_arg")"
    if [ -n "$patchname" ]; then
        dump_patch_file "$PATCHDIR/$patchname"
        exit 0
    fi
    patchname="$(find_first_applied_patch "$name_arg")"
    rc="$?"
    if [ "$rc" -ne 0 ]; then
        exit "$rc"
    fi
    if [ -z "$patchname" ]; then
        # as last resort try if $name_arg is a revision specification:
        patchname="$(git_rev_parse "$name_arg" 2>&1)"
        rc="$?"
        if [ "$rc" -ne 0 ]; then
            patchname=""
        fi
    fi
    if [ -n "$patchname" ]; then
        git show "$patchname"
        exit 0
    fi
    echo "Error, patch '$name_arg' not found." >&2
    exit 1
fi

if [ "$COMMAND" == "applied" ]; then
    PARENT=$(get_parent)
    rc="$?"
    if [ "$rc" -ne 0 ]; then
        exit "$rc"
    fi
    START="${PARENT}.."
    git_oneline_log "$START"
    exit 0
fi

if [ "$COMMAND" == "unapplied" ]; then
    if [ -s "$SERIESFILE" ]; then
        cat "$SERIESFILE"
    fi
    exit 0
fi

if [ "$COMMAND" == "continue" ]; then
    if [ -z "$no_add_opt" ]; then
        # "": do not add unknown files:
        git_add_changes "yes"
    fi
    if ! git am --continue; then
        echo "Fix the change by looking at the *.rej files."
        echo "Then run:"
        echo "  $MYNAME_GIT qcontinue"
        echo "To abort the operation without fixing run:"
        echo "  $MYNAME_GIT qabort"
        exit 1
    fi
    if [ -e "$SERIESFILE.new" ]; then
        cp -a "$SERIESFILE.new" "$SERIESFILE"
    fi
    name_arg=$(cat "$PATCHDIR/PUSH")
    rm -f "$SERIESFILE.new;" "$PATCHDIR/$name_arg" "$PATCHDIR/PUSH"
    exit 0
fi

if [ "$COMMAND" == "abort" ]; then
    git am --abort
    rm -f "$SERIESFILE.new" "$PATCHDIR/PUSH"
    exit 0
fi

echo "Assertion error" >&2
exit 1
