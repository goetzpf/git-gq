#!/bin/bash

# activate if the script should abort on error:
# set -e

SCRIPT_FULL_NAME=$(readlink -e "$0")
#MYDIR=$(dirname "$SCRIPT_FULL_NAME")
MYNAME=$(basename "$SCRIPT_FULL_NAME")

MYNAME_GIT="$(echo "$MYNAME" | sed -s 's/-/ /')"

QUEUENAME="default"
TOPPATCHDIR=".gqpatches"
PATCHDIR="$TOPPATCHDIR/$QUEUENAME"
APPLIEDDIR="$PATCHDIR/applied"
SERIESFILE="$PATCHDIR/series"
PARENTFILE="$PATCHDIR/parent"
QUEUEFILE="$TOPPATCHDIR/queue"

ALL_COMMANDS="abort applied backup bashcompletion change-order commands continue delete doc dump fold goto help init log man name new parent pop push record refresh restore unapplied"

# shellcheck disable=SC2001
ALL_COMMANDS_RX=$(echo "$ALL_COMMANDS" | sed -e 's/ /|/g')

debug=""
all=""
edit=""
message=""
file=""

rev_arg=""
name_arg=""
file_arg=""

patchname=""

function print_doc {
cat << EOF
======================================================
$MYNAME_GIT - patch queues for git
======================================================

Overview
--------

Patches vs. Commits
+++++++++++++++++++

git manages a repository with *commits*. A commit has the following properties:

- A state, this is the directory structure and the files and their contents and
  permissions.
- Metadata: log message, author and date
- A hash key that git uses internally to distinguish commits. Git hashes are
  calculated based on the contents of the files in the commit, the metadata of
  the commit (like timestamp and author), and the parent commit's hash.
- A predecessor commit unless it is the first commit in the repository
- A successor commit unless it is the head commit of a branch

For simplicity, we only consider a single branch for now. Then each commit has
exactly one or no predecessor and one or no successor.

All commits then form an ordered sequence like here::

  A --> B --> C --> D

A *patch* is the difference between two commits combined with the metadata of
the second patch.

So the commits A, B, C and D as shown above could also be represented as patches::

  (A-0) --> (B-A) --> (C-B) --> (D-C)

Here '(B-A)' means the difference of the files and directories of commits 'B'
and 'A'. '0' is the empty state before the very first commit where no files and
directories exist.

When you apply a patch to a commit you get the next commit::

  A + (B-A) = B

The patch queue
+++++++++++++++

The *patch queue* is a structure that contains patches outside of git. Patches
can be moved between the repository and the patch queue. Patches on the patch
queue are called *unapplied*, patches that are in the repository are called
*applied*.

In the following examples, the top of the repository and the patch queue is
always on the right side::

  Repository:  A --> B --> C --> D      Patch-Queue: <empty>
  applied: (A-0), (B-A), (C-B), (D-C)   unapplied: <none>

Now operation 'pop' moves a patch from the repository to the patch-queue::

  Repository:  A --> B --> C            Patch-Queue: (D-C)
  applied: (A-0), (B-A), (C-B)          unapplied: (D-C)

Another 'pop' moves the next patch from the repository to the patch-queue::

  Repository:  A --> B                  Patch-Queue: (D-C) --> (C-B)
  applied: (A-0), (B-A)                 unapplied: (D-C), (C-B)

Operation 'push' moves the top patch from the patch-queue back to the
repository::

  Repository:  A --> B --> C            Patch-Queue: (D-C)
  applied: (A-0), (B-A), (C-B)          unapplied: (D-C)

Advantages of the patch queue
+++++++++++++++++++++++++++++

The patch-queue is much more flexible than traditional commits:

- Patches can be reordered easily
- Patches can be combined ('fold')
- Patches can be updated ('refresh')
- Patches can replace development branches. You can put your local changes on
  the patch queue, run 'git pull' and put your patches back on the repository.

Disadvantages of the patch queue
++++++++++++++++++++++++++++++++

- moving a patch to the patch queue and back changes it's git hash key. This
  means you shouldn't apply this operation on patches that exist in other
  repositories. The definition of the *parent revision* ensures that you cannot
  do this by accident.
- changing the order of patches may lead to *conflicts*.
- Applying new commits in the repository while some patches are unapplied may
  lead to conflicts when the patches are applied later.

Implementation
--------------

Patch files
+++++++++++

A *patch file* is basically a file with recipes for changes in files. Each
recipe is called a *hunk*. A *hunk* contains line numbers, context lines, lines
to remove and lines to add.

\`$MYNAME_GIT\` uses standard git commands to move patches between the
repository and the patch queue. In the patch queue, each patch is a file
created from commits in the repository with \`git format-patch\`. Among the
changes between two commits this file also contains all the metadata of the
second commit.

A patch file is re-applied to the repository with \`git am\`. 

Here is an example of a patch file::

  From 273c3709f7da0fe0e11369ea0d9a26053f78e3ee Mon Sep 17 00:00:00 2001
  From: Goetz Pfeiffer <goetzpf@googlemail.com>
  Date: Tue, 3 Jun 2025 10:45:57 +0200
  Subject: [PATCH] sample-comment
  
  ---
   sample.c | 2 +-
   1 file changed, 1 insertion(+), 1 deletion(-)
  
  diff --git a/sample.c b/sample.c
  index e5cf2b0..350c29b 100644
  --- a/sample.c
  +++ b/sample.c
  @@ -4,8 +4,8 @@ int main(int argc, char *argv[])
     {
       int i;
   
  -    printf("number of arguments: %d\n", argc);
       printf("program name: %s\n", argv[0]);
  +    /* iterate over all command line arguments: */
       for(i=1; i<argc; i++)
         printf("arg no %2d: %s\n", i, argv[i]);
       return 0;
  -- 
  2.49.0

The series file
+++++++++++++++

The order of patches is kept in a file named 'series' that just contains all
the filenames of all unapplied patches. This file is maintained by
\`$MYNAME_GIT\`.

Parent revision
+++++++++++++++

The parent revision is stored in a file 'parent'. This is the latest commit
that is not allowed to be modified. This file is usually created when you start
your work with \`$MYNAME_GIT init\`.

Multiple patch queues
+++++++++++++++++++++

Multiple patch queues are maintained in different directories. There is always
one patch queue active, it's name is stored in the file 'queue'.

Conflicts and conflict resolution
---------------------------------

Conflicts may happen when:

- you change the order of unapplied patches with \`$MYNAME_GIT change-order\`
  and then run \`$MYNAME_GIT push\`
- you unapply patches, make changes in the repository, e.g. \`git pull\` and
  then apply the patches again
- you combine unapplied patches with \`$MYNAME_GIT fold\` that are not in
  consecutive order

In the patch file example above, you see after '@@ -4,8 +4,8 @@' a single
*hunk*. The numbers are line numbers in the source file, here 'sample.c'.

All following lines that are indented with a single space are *context* lines.
Lines that start with a '-' character are to be removed, lines that start with
a '+' character are to be added.

A conflict occurs when the context lines or the lines to be removed couldn't be
found. In this case, a reject file is created.

Here are the messages you see in case of a conflict after you ran \`$MYNAME_GIT
push\`::

  $ ../../bin/git-gq push
  Applying: sample-comment
  Checking patch sample.c...
  error: while searching for:
    {
      int i;
  
      printf("number of arguments: %d\n", argc);
      printf("program name: %s\n", argv[0]);
      for(i=1; i<argc; i++)
        printf("arg no %2d: %s\n", i, argv[i]);
      return 0;
  
  error: patch failed: sample.c:4
  Applying patch sample.c with 1 reject...
  Rejected hunk #1.
  Patch failed at 0001 sample-comment
  hint: Use 'git am --show-current-patch=diff' to see the failed patch
  hint: When you have resolved this problem, run "git am --continue".
  hint: If you prefer to skip this patch, run "git am --skip" instead.
  hint: To restore the original branch and stop patching, run "git am --abort".
  hint: Disable this message with "git config set advice.mergeConflict false"
  Fix the change by looking at the *.rej files.
  Then run:
    git-gq continue
  To abort the operation without fixing run:
    git-gq abort

And here is the content of the reject file, 'sample.c.rej' in this case::

  diff a/sample.c b/sample.c	(rejected hunks)
  @@ -4,8 +4,8 @@ int main(int argc, char *argv[])
     {
       int i;
   
  -    printf("number of arguments: %d\n", argc);
       printf("program name: %s\n", argv[0]);
  +    /* iterate over all command line arguments: */
       for(i=1; i<argc; i++)
         printf("arg no %2d: %s\n", i, argv[i]);
       return 0;

In our example here, while the patch was moved to the patch queue, this line::

  printf("number of arguments: %d\n", argc);

had been changed to::

  printf("My number of arguments: %d\n", argc);

So the line to remove by the patch wasn't found and we had a conflict. If we
open both, the original file 'sample.c' and the reject file 'sample.c.rej' in
any text editor, we can easily see what the patch intended to do and apply the
changes manually.

This is called *resolving a conflict*. You have to go through all reject files,
there may be more than one and resolve all conflicts.

After you are finished, run::

  $MYNAME_GIT continue

This finishes the operation and tells git that the conflict was resolved. You
*must not* run \`git am continue\` yourself, \`$MYNAME_GIT\` already does this
for you.

If you cannot resolve conflicts because the reject files are too long or
complicated, you can abort the last command with::

  $MYNAME_GIT abort

In this case you may have to compare two versions of files and apply changes
directly.

Example Workflows
-----------------

Local development
+++++++++++++++++

Assuming you have cloned another git repository and want to start development
here. With \`$MYNAME_GIT\` you don't need to create a local branch. Just run::

  $MYNAME_GIT init

This sets up the \`$MYNAME_GIT\` directory and marks the current HEAD revision
as parent revision.

You can now begin to make changes. You create preliminary commits with::

  $MYNAME_GIT new NAME

where NAME should be a one line string with no spaces in it. This is a
preliminary log message that you can later update and extend. Every time you
make more changes you can either:

- run \`$MYNAME_GIT new\` to create a new commit
- run \`$MYNAME_GIT refresh\` to update the topmost commit
- run the \`git add..\` and \`git commit\` as usual to create a new commit

You can see what patches are applied with::

  $MYNAME_GIT applied

You can see what patches are unapplied with::

  $MYNAME_GIT unapplied

When you want to finalize your commits and update commit messages, first move
all of them as patches to the patch queue::

  $MYNAME_GIT pop -a

Then for each patch, to provide a proper log message, run::

  $MYNAME_GIT push
  $MYNAME_GIT refresh -e

You can also combine ('fold') an unapplied patch with::

  $MYNAME_GIT fold PATCH

Inspect the applied patches with::

  $MYNAME_GIT log

When you are finished for all patches you can finalize these changes by setting
the parent version to the current HEAD version::

  $MYNAME_GIT parent HEAD

You are now ready to publish your patches.

Updates from a remote repository
++++++++++++++++++++++++++++++++

When you have created local patches and want to update your repository with new
patches from a remote repository, the usual way would be to run
\`git pull\` and then \`git merge\` or \`git rebase -i\`.

With the patch queue, there is now another way to handle this. Before pulling
patches from the public repository, put all your local changes on the patch
queue::

  $MYNAME_GIT pull -a

As a safety measure backup your patch queue with::

  $MYNAME_GIT backup

Now pull patches from the remote repository::

  git pull

Reset the parent revision to the new repository HEAD::

  $MYNAME_GIT parent HEAD

Finally re-apply all your patches::

  $MYNAME_GIT push -a

If you get messages about conflicts ("rejects") you have to resolve them. See
further above at "Conflicts and conflict resolution".

This workflow allows to resolve conflicts step by step which is usually easier
than resolving all conflicts that arise from \`git pull\` all at once. Also the
reject files created for each conflict clearly show which change was intended
at the patch which is usually easier than the common 3-way merge.

Command line interface
----------------------
EOF
short_help_text
}

function print_short_help {
    short_help_text | grep -v '^+\+$'
}

function git_goto_repo_dir {
    while [ "$(pwd)" != "/" ]; do
        if [ -d ".git" ]; then
            break;
        fi
        cd .. || exit 1
    done
    if [ ! -d ".git" ]; then
        echo "error, '.git' not found" >&2
        exit 1
    fi
}

function find_single_unapplied_patch {
    # $1: regexp
    # finds unapplied patch
    # exits the script if more than one patch matches !
    if [ ! -e "$SERIESFILE" ]; then
        echo ""
        return
    fi
    if [ 1 -ne "$(grep -c "$1" "$SERIESFILE")" ]; then
        echo "ERR:MULTI"
        return
    fi
    grep "$1" "$SERIESFILE"
}

function find_first_unapplied_patch {
    # $1: regexp
    # finds unapplied patch
    if [ ! -e "$SERIESFILE" ]; then
        echo ""
        return
    fi
    grep "$1" "$SERIESFILE" | head -n 1
}

function find_first_applied_patch {
    # $1: regexp
    # finds applied patch, returns hash key
    local START
    START="$(cat "$PARENTFILE").."
    git log --oneline "$START" | grep "$1" | head -n 1 | sed -e 's/ .*//'
}

function find_head_patch {
    # $1: regexp
    # finds applied patch, returns hash key
    git log --oneline -1 | grep "$1" | sed -e 's/ .*//'
}

function find_applied_top_patch {
    # $1: regexp
    # finds applied top patch, returns hash key
    local START
    git log --oneline HEAD | grep "$1" | sed -e 's/ .*//'
}

function dump_patch_file {
    # $1: file
    if [ -t 1 ]; then
        colordiff < "$1" | less -R
    else
        cat "$1"
    fi
}

function git_head_log {
    # $1: name of file to create
    git log -1 --pretty=%B > "$1"
}

function git_add_changes {
    # add only changes files to stash
    git status --porcelain | grep -v '^??' | sed -e 's/^.. //' | grep -v "\(^${TOPPATCHDIR}[/-]\|\.rej$\)" |xargs git add
}

function git_select_changes {
    # add only changes files to stash
    git add --patch
}

function git_add_all_changes {
    # add all changes except patchqueue files
    git status --porcelain | sed -e 's/^.. //' | grep -v "\(^${TOPPATCHDIR}[/-]\|\.rej$\)" | xargs git add
}

function git_amend {
    # simple amend of HEAD revision
    # $1: if not empty, this is the log message
    # $2: if not empty, take log message from this file
    local EXTRA
    EXTRA=()
    if [ -n "$1" ]; then
        EXTRA+=("-m" "$1")
    fi
    if [ -n "$2" ]; then
        EXTRA+=("-F" "$2")
    fi
    git_add_changes
    # shellcheck disable=SC2086
    git commit --amend "${EXTRA[@]}"
}

function save_applied_patches {
    # save all applied patches
    local PARENT
    local rev
    if [ ! -s "$PARENTFILE" ]; then
        echo "Error, $PARENTFILE is empty/non-existent" >&2
        exit 1
    fi
    PARENT=$(cat "$PARENTFILE")
    rev=$(git rev-parse --short HEAD)
    rm -rf "$APPLIEDDIR"
    if [ "$rev" != "$PARENT" ]; then
        mkdir -p "$APPLIEDDIR"
        git format-patch -o "$APPLIEDDIR" "$PARENT.."
    fi
}

function del_applied_patches {
    rm -rf "$APPLIEDDIR"
}

function select_queue {
    # $1: queue name
    # modifies global variables: QUEUENAME, PATCHDIR, SERIESFILE,
    #                            PARENTFILE
    QUEUENAME="$1"
    PATCHDIR="$TOPPATCHDIR/$QUEUENAME"
    APPLIEDDIR="$PATCHDIR/applied"
    SERIESFILE="$PATCHDIR/series"
    PARENTFILE="$PATCHDIR/parent"
}

function qpop_check {
    # returns 0 if qpop is not beyond parent,
    # returns 1 when qpop is not allowed.
    # $1: if non-zero, instead of returning 1 abort with an error message
    local rev
    rev=$(git rev-parse --short HEAD)
    if [ -s "$PARENTFILE" ] && [ "$(cat "$PARENTFILE")" == "$rev" ]; then
        if [ -n "$1" ]; then
            echo "Cannot perform pop, parent revision $rev reached." >&2
            echo "You could change the parent with '$MYNAME_GIT parent REV'." >&2
            exit 1
        else
            return 1
        fi
    fi
    return 0
}

function qpop_one {
    # do a single 'qpop' operation.
    local ORIG_PATCHNAME
    local PATCHNAME
    local TEMP_PATCHNAME
    local CNT
    ORIG_PATCHNAME=$(git format-patch -o "$TOPPATCHDIR" -1 HEAD | sed -e "s#^$TOPPATCHDIR/##")
    # remove leading number from patchname:
    # shellcheck disable=SC2001
    PATCHNAME=$(echo "$ORIG_PATCHNAME"  | sed -e 's/^[0-9]\+-//')
    # if a file with this name already exists:
    if [ -e "$PATCHDIR/$PATCHNAME" ]; then
        # generate a filename with a preceeding number
        CNT=1
        while true; do
            TEMP_PATCHNAME="$(printf "%04d-%s" "$CNT" "$PATCHNAME")"
            if [ ! -e "$PATCHDIR/$TEMP_PATCHNAME" ]; then
                break
            fi
            CNT=$((CNT+1))
        done
        PATCHNAME="$TEMP_PATCHNAME"
    fi
    mv "$TOPPATCHDIR/$ORIG_PATCHNAME" "$PATCHDIR/$PATCHNAME"
    if [ ! -s "$SERIESFILE" ]; then
        echo "$PATCHNAME" > "$SERIESFILE"
    else
        # insert at first line
        sed -i "1i$PATCHNAME" "$SERIESFILE"
    fi
    git reset --hard HEAD~1
}

function qpush_specified {
    # $1: name of patch
    local PATCHNAME
    if [ ! -s "$SERIESFILE" ]; then
        echo "Error, all patches in queue are already applied." >&2
        exit 1
    fi
    PATCHNAME=$(grep -F -e "$name_arg" "$SERIESFILE")
    if [ -z "$PATCHNAME" ]; then
        echo "error, patch '$name_arg' not found in $SERIESFILE, maybe the patch is alraedy applied" >&2
        exit 1
    fi
    echo "$PATCHNAME" > "$PATCHDIR/PUSH"
    # remove PATCHNAME from SERIESFILE:
    grep -v -F -e "$name_arg" "$SERIESFILE" > "$SERIESFILE.new"
    if ! git am --reject "$PATCHDIR/$PATCHNAME" 2>&1; then
        echo "The patch to be folded could not be applied."
        echo "Fix the change by looking at the *.rej files."
        echo "Then run:"
        echo "  $MYNAME continue"
        echo "To abort the operation without fixing run:"
        echo "  $MYNAME abort"
        exit 1
    fi
    rm -f "$PATCHDIR/$PATCHNAME" "$PATCHDIR/PUSH" "$SERIESFILE" && mv "$SERIESFILE.new" "$SERIESFILE"
}

function qpush_one {
    # do a single 'qpush' operation.
    local PATCHNAME
    if [ ! -s "$SERIESFILE" ]; then
        echo "Error, all patches in queue are already applied." >&2
        exit 1
    fi
    PATCHNAME=$(head -n 1 "$SERIESFILE")
    echo "$PATCHNAME" > "$PATCHDIR/PUSH"
    # remove PATCHNAME from SERIESFILE:
    cp -a "$SERIESFILE" "$SERIESFILE.new" && sed -i -e '1d' "$SERIESFILE.new"
    if ! git am --reject "$PATCHDIR/$PATCHNAME" 2>&1; then
        echo "Fix the change by looking at the *.rej files."
        echo "Then run:"
        echo "  $MYNAME continue"
        echo "To abort the operation without fixing run:"
        echo "  $MYNAME abort"
        exit 1
    fi
    rm -f "$PATCHDIR/$PATCHNAME" "$PATCHDIR/PUSH" "$SERIESFILE" && mv "$SERIESFILE.new" "$SERIESFILE"
}

function qdelete {
    # $1: name of patch to delete
    local name
    local patchname
    name="$1"
    patchname=$(find_single_unapplied_patch "$name")
    if [ "$patchname" == "ERR:MULTI" ]; then
        echo "Error, more than one unapplied patch matches" >&2
        exit 1
    fi
    if [ -z "$patchname" ]; then
        echo "Error, patch '$name' not found." >&2
        exit 1
    fi
    rm "$PATCHDIR/$patchname"
    if [ -s "$SERIESFILE" ]; then
        cp -a "$SERIESFILE" "$SERIESFILE.bak" && grep -v -F -e "$patchname" "$SERIESFILE.bak" > "$SERIESFILE" && rm -f "$SERIESFILE.bak;"
    fi
}

function create_parentfile {
    # $1: revision
    local rev
    rev=$(git rev-parse --short "$1")
    # shellcheck disable=SC2181
    if [ $? -ne 0 ]; then
        echo "invalid revision: $1" >&2
        exit 1
    fi
    if [ "$1" == "$rev" ]; then
        echo "queue parent revision set to $1"
    else
        echo "queue parent revision set to $1 ($rev)"
    fi
    echo "$rev" > "$PARENTFILE"
}

function short_help_text {
cat << EOF
$MYNAME : handle git patch queues

usage: $MYNAME_GIT COMMAND [OPTIONS]

Bash completion commands
++++++++++++++++++++++++

  commands       
    List all known commands on the console

  bashcompletion 
    List the line you have to add to your .bashrc
    to integrate completion into the 'git' command.

Queue management commands
+++++++++++++++++++++++++

  init [QNAME]   
    Create/select a patch queue with name 'QNAME'. QNAME is optional, the
    default patch queue name is 'default'. You must run this command once to
    initialize the patch queue in your repository.

  name [QNAME]   
    If QNAME is not given, show current patch queue name. if QNAME is given,
    change to patch queue QNAME.

  backup         
    Create backup tar file of patch directory '$TOPPATCHDIR'.

  restore FILE   
    Restore patch directory from a backup file. '$TOPPATCHDIR'.

  change-order   
    Call an editor to edit the file that contains all currently unapplied
    patches. Note the the patches in the file are applied from top to bottom.

  applied    
    Show all applied patches up to parent+1.

  unapplied      
    Show all patches of the patch queue.

  parent [REV}   
    Set REV as patch queue parent revision. Do never go beyond this revision
    with pop. Use 'HEAD' to set your repository HEAD as parent revision. If
    HEAD is not given, show the current parent revision.

Patch management commands
+++++++++++++++++++++++++

  new [NAME]     
    Create new patch (commit with log-message NAME).

  record [NAME]  
    Interactively select changes for a new patch (commit with log-message NAME)

  refresh        
    Update the topmost patch.

  pop            
    Pop the topmost patch.

  push           
    Apply the top patch from the patch queue.

  goto NAME|REGEXP
    Do push or pop until the specified patch is the latest applied patch.

  fold NAME|REGEXP
    Fold patch 'NAME' to the topmost patch. Patch 'NAME' must not be appled
    already. Note that the log message of the fold-patch is appended to the
    existing log message. You may change the log message with \`$MYNAME_GIT
    refresh -e\`.

  delete NAME|REGEXP
    Delete unapplied patch with given name.

  dump NAME|REGEXP
    Dump an applied or unapplied patch to the console.

  continue       
    Continue 'push' after you had a conflict and had it fixed manually.

  abort          
    Abort (undo) 'push' after you had a conflict and could not fix it manually.

Miscellaneous commands
++++++++++++++++++++++

  help           
    Show this help.

  doc            
    Show reStructuredText source of man page.

  man            
    Show man page.

  log            
    Display applied patches (commits) as a tree on the console.

OPTIONS
+++++++

  -h --help
    Show help.

  -H --HELP
    Show help without pager.

  -a --all
    push/pop: apply on ALL patches.

  -e --edit
    refresh: edit log message

  -m --message MESSAGE
    refresh: use MESSAGE as log message

  -F --file FILE
    refresh: take log message from FILE.
EOF
}

function pager_help {
    if less -V >/dev/null 2>&1; then
        # use less pager for help:
        $SCRIPT_FULL_NAME --HELP | less
    else
        print_short_help
    fi
}

function manpage {
    # display man page generated with rst2man
    if ! rst2man --version > /dev/null; then
        echo "rst2man not found, display reStructuredText instead." >&2
        if less -V >/dev/null 2>&1; then
            # use less pager for help:
            $SCRIPT_FULL_NAME doc | less
        else
            print_doc
        fi
    else
        $SCRIPT_FULL_NAME doc | rst2man | man -l -
    fi
}

declare -a ARGS
skip_options=""

while true; do
    case "$1" in
        -h | --help)
            pager_help
            exit 0
            ;;
        -H | --HELP)
            print_short_help
            exit 0
            ;;
        -a | --all)
            all="yes"
            shift
            ;;
        -e | --edit)
            edit="yes"
            shift
            ;;
        -m | --message)
            message="$2"
            shift 2
            ;;
        -F | --file)
            file="$2"
            shift 2
            ;;
        --debug)
            debug="yes"
            shift
            ;;
        -- )
            skip_options="yes"
            shift;
            break
            ;;
        *)
            if [ -z "$1" ]; then
                break;
            fi
            if [[ $1 =~ ^- ]]; then
                echo "unknown option: $1"
                exit 1
            fi
            ARGS+=("$1")
            shift
            ;;
    esac
done

if [ -n "$skip_options" ]; then
    while true; do
        if [ -z "$1" ]; then
            break;
        fi
        ARGS+=("$1")
        shift
    done
fi

COMMAND=""

for arg in "${ARGS[@]}"; do
    # examine extra args
    # match known args here like:
    # if [ "§arg" == "doit" ]; then ...
    #     continue
    # fi
    if [ "$COMMAND" == "restore" ]; then
        if [ -n "$file_arg" ]; then
            echo "unexpected: '$arg'" >&2
            exit 1
        fi
        file_arg="$arg"
        continue
    fi
    if [ "$COMMAND" == "parent" ]; then
        if [ -n "$rev_arg" ]; then
            echo "unexpected: '$arg'" >&2
            exit 1
        fi
        rev_arg="$arg"
        continue
    fi
    if [[ "$COMMAND" =~ init|fold|goto|new|record|delete|dump ]]; then
        if [ -n "$name" ]; then
            echo "unexpected: '$arg'" >&2
            exit 1
        fi
        name_arg="$arg"
        continue
    fi
    if [[ "$arg" =~ $ALL_COMMANDS_RX ]]; then
        if [ -n "$COMMAND" ]; then
            echo "unexpected: '$arg'" >&2
            exit 1
        fi
        COMMAND="$arg"
        continue
    fi
    echo "unexpeced argument: $arg"
    exit 1
done

if [ -n "$debug" ]; then
    set -x
fi

if [ -z "$COMMAND" ] || [ "$COMMAND" == "help" ]; then
    manpage
    exit 0
fi

if [ "$COMMAND" == "doc" ]; then
    print_doc
    exit 0
fi

if [ "$COMMAND" == "man" ]; then
    manpage
    exit 0
fi

if [ "$COMMAND" == "commands" ]; then
    echo -n "$ALL_COMMANDS"
    exit 0
fi

if [ "$COMMAND" == "bashcompletion" ]; then
    # shellcheck disable=SC2016
    echo '_git_gq() { __gitcomp "$(git-gq commands)" "" "$cur"; }'
    exit 0
fi

if [ -n "$file_arg" ]; then
    if [ ! -e "$file_arg" ]; then
        echo "Error, file $file_arg doesn't exist." >&2
        exit 1
    fi
    # convert 'file_arg' to an absolute path:
    file_arg="$(readlink -e "$file_arg")"
fi

git_goto_repo_dir

if [ "$COMMAND" == "restore" ]; then
    if [ -d "$TOPPATCHDIR" ]; then
        echo "Error, $TOPPATCHDIR already exists, you must remove/delete">&2
        echo "this first.">&2
        exit 1
    fi
    tar -xzf "$file_arg"
    QUEUENAME=$(cat "$QUEUEFILE")
    select_queue "$QUEUENAME"
    PARENT=$(cat "$PARENTFILE")
    git reset --hard "$PARENT"
    if [ -d "$APPLIEDDIR" ]; then
        # shellcheck disable=SC2086
        git am $APPLIEDDIR/*.patch
    fi
    rm -rf "$APPLIEDDIR"
    exit 0
fi

if [ "$COMMAND" == "init" ]; then
    if [ -n "$name_arg" ]; then
        QUEUENAME="$name_arg"
    fi
    mkdir -p "$TOPPATCHDIR"
    echo "$QUEUENAME" > "$QUEUEFILE"
    select_queue "$QUEUENAME"
    mkdir -p "$TOPPATCHDIR/$QUEUENAME"
    if [ ! -s "$PARENTFILE" ]; then
        create_parentfile HEAD
    fi
    exit 0
fi

if [ ! -d "$TOPPATCHDIR" ]; then
    echo "please run '$MYNAME init' first." >&2
    exit 1
fi

if [ "$COMMAND" == "name" ]; then
    if [ -z "$name_arg" ]; then
        QUEUENAME=$(cat "$QUEUEFILE")
        echo "Existing queues:"
        (cd $TOPPATCHDIR && find . -type d | grep -v '^\.$' | sed -e 's#^\./#\t#')
        echo
        echo "Currently selected:"
        echo -e "\t$QUEUENAME"
        exit 0
    else
        echo "$QUEUENAME" > "$QUEUEFILE"
        select_queue "$QUEUENAME"
        mkdir -p "$PATCHDIR/$QUEUENAME"
        if [ ! -s "$PARENTFILE" ]; then
            create_parentfile HEAD
        fi
    fi
fi

QUEUENAME=$(cat "$QUEUEFILE")
if [ ! -d "$PATCHDIR" ]; then
    echo "error: $PATCHDIR does not exist" >&2
    exit 1
fi
select_queue "$QUEUENAME"

if [ "$COMMAND" == "backup" ]; then
    save_applied_patches
    date_=$(date '+%Y-%m-%dT%H%M%S')
    tar -czf "$TOPPATCHDIR-$date_.tgz" "$TOPPATCHDIR"
    del_applied_patches
    exit 0
fi

if [ "$COMMAND" == "change-order" ]; then
    editor="$EDITOR"
    if [ -z "$EDITOR" ]; then
        editor="$VISUAL"
    fi
    if [ -z "$EDITOR" ]; then
        echo "Caution: default editor not set, using 'vi' instead."
        echo "Note that you can abort editing with"
        echo "  <ESC> :qa!"
        read -p "Enter 'y' or 'Y' to continue, everything else aborts " -n 1 -r
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 1
        fi
        editor="vi"
    fi
    $editor "$SERIESFILE"
    exit 0
fi

if [ "$COMMAND" == "log" ]; then
    git log --graph --all --decorate
    exit 0
fi

if [ "$COMMAND" == "parent" ]; then
    if [ -z "$rev_arg" ]; then
        if [ ! -s "$PARENTFILE" ]; then
            echo "no PARENT revision defined"
        else
            echo "Parent: $(cat "$PARENTFILE")"
        fi
        exit 0
    fi
    create_parentfile "$rev_arg"
    exit 0
fi

if [ "$COMMAND" == "new" ]; then
    git_add_changes
    if [ -n "$name_arg" ]; then
        # shellcheck disable=SC2089
        name_opt=("-m" "$name_arg")
    else
        name_opt=()
    fi
    git commit "${name_opt[@]}"
    exit 0
fi

if [ "$COMMAND" == "record" ]; then
    git_select_changes
    EXTRA=()
    if [ -n "$name_arg" ]; then
        EXTRA=("-m" "$name_arg")
    fi
    git commit "${EXTRA[@]}"
    exit 0
fi

if [ "$COMMAND" == "refresh" ]; then
    if [ -z "$message" ] && [ -z "$file" ] && [ -z "$edit" ]; then
        # re-use existing log message and keep this as
        # log message
        git log --format=%B -1 > "$PATCHDIR/LOG"
        git_amend "" "$PATCHDIR/LOG"
        rm -f "$PATCHDIR/LOG"
    else
        # if $message and $file are empty, this starts an editor for changing
        # the log message.
        git_amend "$message" "$file"
    fi
    exit 0
fi

if [ "$COMMAND" == "delete" ]; then
    if [ -z "$name_arg" ]; then
        echo "error, patchname is missing" >&2
        exit 1
    fi
    qdelete "$name_arg"
    exit 0
fi

if [ "$COMMAND" == "pop" ]; then
    abort_on_err=""
    if [ -z "$all" ]; then
        abort_on_err="yes"
    else
        if [ ! -s "$PARENTFILE" ]; then
            echo "Error, 'pop -a' not allowed when no parent revision is defined." >&2
            exit 1
        fi
    fi
    while true; do
        if ! qpop_check "$abort_on_err"; then
            break
        fi
        qpop_one
        if [ -z "$all" ]; then
            break
        fi
    done
    exit 0
fi

if [ "$COMMAND" == "push" ]; then
    while true; do
        qpush_one
        if [ -z "$all" ]; then
            break
        else
            # with "--all", reaching the end is no error:
            if [ ! -s "$SERIESFILE" ]; then
                break
            fi
        fi
    done
    exit 0
fi

if [ "$COMMAND" == "goto" ]; then
    if [ -z "$name_arg" ]; then
        echo "error, patchname is missing" >&2
        exit 1
    fi
    patchname=$(find_first_unapplied_patch "$name_arg")
    if [ -n "$patchname" ]; then
        while true; do
            qpush_one
            if [ -z "$(find_first_unapplied_patch "$patchname")" ]; then
                break
            fi
        done
        exit 0
    fi
    patchname=$(find_first_applied_patch "$name_arg")
    if [ -n "$patchname" ]; then
        while [ -z "$(find_head_patch "$patchname")" ]; do
            qpop_one
        done
        exit 0
    fi
    echo "Error, patch '$name_arg' not found."
    exit 1
fi

if [ "$COMMAND" == "fold" ]; then
    if [ -z "$name_arg" ]; then
        echo "error, patchname is missing" >&2
        exit 1
    fi
    if [ ! -e "$PATCHDIR/$name_arg" ]; then
        patchname=$(find_single_unapplied_patch "$name_arg")
        if [ "$patchname" == "ERR:MULTI" ]; then
            echo "Error, more than one unapplied patch matches" >&2
            exit 1
        fi
        if [ -z "$patchname" ]; then
            echo "Error, patch '$name_arg' not found." >&2
            exit 1
        fi
        name_arg="$patchname"
    fi
    git_head_log "$PATCHDIR/LOG"
    echo -e '\n***\n' >> "$PATCHDIR/LOG"
    qpush_specified "$name_arg"
    git_head_log "$PATCHDIR/LOG2"
    cat "$PATCHDIR/LOG2" >> "$PATCHDIR/LOG" && rm -f "$PATCHDIR/LOG2"
    qpop_one
    git apply "$PATCHDIR/$name_arg"
    git_amend "" "$PATCHDIR/LOG"
    rm -f "$PATCHDIR/LOG"
    qdelete "$name_arg"
    echo "Note: Log messages were combined into one"
    exit 0
fi

if [ "$COMMAND" == "dump" ]; then
    patchname="$name_arg"
    if [ -e "$PATCHDIR/$patchname" ]; then
        dump_patch_file "$PATCHDIR/$patchname"
        exit 0
    fi
    patchname="$(find_first_unapplied_patch "$name_arg")"
    if [ -n "$patchname" ]; then
        dump_patch_file "$PATCHDIR/$patchname"
        exit 0
    fi
    patchname="$(find_first_applied_patch "$name_arg")"
    if [ -n "$patchname" ]; then
        git show "$patchname"
        exit 0
    fi
    echo "error, patch '$name_arg' not found" >&2
    exit 1
fi

if [ "$COMMAND" == "applied" ]; then
    if [ -s "$PARENTFILE" ]; then
        START="$(cat "$PARENTFILE").."
    fi
    # shellcheck disable=SC2209
    GIT_PAGER=cat git log --color=auto --oneline "$START" 
    exit 0
fi

if [ "$COMMAND" == "unapplied" ]; then
    if [ -s "$SERIESFILE" ]; then
        cat "$SERIESFILE"
    fi
    exit 0
fi

if [ "$COMMAND" == "continue" ]; then
    git status --porcelain | sed -e "s/^.. //" | grep -v "\(^$PATCHDIR/\|\.rej$\)"| xargs git add
    if ! git am --continue; then
        echo "Fix the change by looking at the *.rej files."
        echo "Then run:"
        echo "  $MYNAME qcontinue"
        echo "To abort the operation without fixing run:"
        echo "  $MYNAME qabort"
        exit 1
    fi
    if [ -e "$SERIESFILE.new" ]; then
        cp -a "$SERIESFILE.new" "$SERIESFILE"
    fi
    name_arg=$(cat "$PATCHDIR/PUSH")
    rm -f "$SERIESFILE.new;" "$PATCHDIR/$name_arg" "$PATCHDIR/PUSH"
    exit 0
fi

if [ "$COMMAND" == "abort" ]; then
    git am --abort
    rm -f "$SERIESFILE.new" "$PATCHDIR/PUSH"
    exit 0
fi

if [ "$COMMAND" == "continue" ]; then
    git_add_all_changes
    if ! git am --continue; then
        echo "Fix the change by looking at the *.rej files."
        echo "Then run:"
        echo "  $MYNAME qcontinue"
    fi
    if [ -e "$SERIESFILE.new" ]; then
        rm "$SERIESFILE" && mv "$SERIESFILE.new" "$SERIESFILE"
    fi
    exit 0
fi
